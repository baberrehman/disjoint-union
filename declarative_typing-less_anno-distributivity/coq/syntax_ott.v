(* generated by Ott 0.31, locally-nameless lngen from: ../spec/rules.ott *)
Require Import Metalib.Metatheory.
(** syntax *)
Definition i : Set := nat.

Inductive typ : Set :=  (*r type *)
 | t_top : typ
 | t_int : typ
 | t_bot : typ
 | t_arrow (A:typ) (B:typ)
 | t_or (A:typ) (B:typ)
 | t_and (A:typ) (B:typ).

Inductive exp : Set :=  (*r expression *)
 | e_var_b (_:nat)
 | e_var_f (x:var)
 | e_lit (i5:i)
 | e_ann (e:exp) (A:typ)
 | e_abs (A:typ) (e:exp)
 | e_app (e1:exp) (e2:exp)
 | e_switch (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp).

Definition ctx : Set := list ( atom * typ ).

Inductive dirflag : Set :=  (*r typing direction *)
 | infer : dirflag
 | check : dirflag.

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | (e_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e_var_b nat
        | inleft (right _) => e_5
        | inright _ => e_var_b (nat - 1)
      end
  | (e_var_f x) => e_var_f x
  | (e_lit i5) => e_lit i5
  | (e_ann e A) => e_ann (open_exp_wrt_exp_rec k e_5 e) A
  | (e_abs A e) => e_abs A (open_exp_wrt_exp_rec (S k) e_5 e)
  | (e_app e1 e2) => e_app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (e_switch e A e1 B e2) => e_switch (open_exp_wrt_exp_rec k e_5 e) A (open_exp_wrt_exp_rec (S k) e_5 e1) B (open_exp_wrt_exp_rec (S k) e_5 e2)
end.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_e_var_f : forall (x:var),
     (lc_exp (e_var_f x))
 | lc_e_lit : forall (i5:i),
     (lc_exp (e_lit i5))
 | lc_e_ann : forall (e:exp) (A:typ),
     (lc_exp e) ->
     (lc_exp (e_ann e A))
 | lc_e_abs : forall (A:typ) (e:exp),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (e_var_f x) )  )  ->
     (lc_exp (e_abs A e))
 | lc_e_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_app e1 e2))
 | lc_e_switch : forall (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp),
     (lc_exp e) ->
      ( forall x , lc_exp  ( open_exp_wrt_exp e1 (e_var_f x) )  )  ->
      ( forall x , lc_exp  ( open_exp_wrt_exp e2 (e_var_f x) )  )  ->
     (lc_exp (e_switch e A e1 B e2)).
(** free variables *)
Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | (e_var_b nat) => {}
  | (e_var_f x) => {{x}}
  | (e_lit i5) => {}
  | (e_ann e A) => (fv_exp e)
  | (e_abs A e) => (fv_exp e)
  | (e_app e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (e_switch e A e1 B e2) => (fv_exp e) \u (fv_exp e1) \u (fv_exp e2)
end.

(** substitutions *)
Fixpoint subst_exp (e_5:exp) (x5:var) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | (e_var_b nat) => e_var_b nat
  | (e_var_f x) => (if eq_var x x5 then e_5 else (e_var_f x))
  | (e_lit i5) => e_lit i5
  | (e_ann e A) => e_ann (subst_exp e_5 x5 e) A
  | (e_abs A e) => e_abs A (subst_exp e_5 x5 e)
  | (e_app e1 e2) => e_app (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
  | (e_switch e A e1 B e2) => e_switch (subst_exp e_5 x5 e) A (subst_exp e_5 x5 e1) B (subst_exp e_5 x5 e2)
end.


(** definitions *)

(* defns Value *)
Inductive value : exp -> Prop :=    (* defn value *)
 | value_int : forall (i5:i),
     value (e_lit i5)
 | value_abs : forall (A:typ) (e:exp),
     lc_exp (e_abs A e) ->
     value (e_abs A e).

(* defns FindType *)
Inductive findtype : exp -> typ -> Prop :=    (* defn findtype *)
 | findtype_int : forall (i5:i),
     findtype (e_lit i5) t_int
 | findtype_arrow : forall (A:typ) (e:exp),
     lc_exp (e_abs A e) ->
     findtype (e_abs A e) (t_arrow A t_bot).

(* defns Ordinary *)
Inductive ordinary : typ -> Prop :=    (* defn ordinary *)
 | ord_top : 
     ordinary t_top
 | ord_int : 
     ordinary t_int
 | ord_arrow : forall (A B:typ),
     ordinary (t_arrow A B).

(* defns Subtyping *)
Inductive sub : typ -> typ -> Prop :=    (* defn sub *)
 | s_refl : forall (A:typ),
     sub A A
 | s_trans : forall (A C B:typ),
     sub A B ->
     sub B C ->
     sub A C
 | s_top : forall (A:typ),
     sub A t_top
 | s_btm : forall (A:typ),
     sub t_bot A
 | s_int : 
     sub t_int t_int
 | s_arrow : forall (A1 A2 B1 B2:typ),
     sub B1 A1 ->
     sub A2 B2 ->
     sub (t_arrow A1 A2) (t_arrow B1 B2)
 | s_ora : forall (A1 A2 A:typ),
     sub A1 A ->
     sub A2 A ->
     sub (t_or A1 A2) A
 | s_orb : forall (A1 A2:typ),
     sub A1 (t_or A1 A2)
 | s_orc : forall (A2 A1:typ),
     sub A2 (t_or A1 A2)
 | s_anda : forall (A A1 A2:typ),
     sub A A1 ->
     sub A A2 ->
     sub A (t_and A1 A2)
 | s_andb : forall (A1 A2:typ),
     sub (t_and A1 A2) A1
 | s_andc : forall (A1 A2:typ),
     sub (t_and A1 A2) A2
 | s_distarr : forall (A B1 B2:typ),
     sub (t_and  ( (t_arrow A B1) )   ( (t_arrow A B2) ) ) (t_arrow A  ( (t_and B1 B2) ) )
 | s_distarru : forall (A1 B A2:typ),
     sub (t_and  ( (t_arrow A1 B) )   ( (t_arrow A2 B) ) ) (t_arrow  ( (t_or A1 A2) )  B)
 | s_distor : forall (A1 B A2:typ),
     sub (t_and  ( (t_or A1 B) )   ( (t_or A2 B) ) ) (t_or  ( (t_and A1 A2) )  B).

(* defns Typing *)
(****************************************)
(**********  Dijoint Specs    ***********)
(****************************************)

Definition DisjSpec A B := forall C, ordinary C -> sub C (t_and A B) -> False.
Notation "A *s B" := (DisjSpec A B) (at level 80).
Inductive typing : ctx -> exp -> typ -> Prop :=    (* defn typing *)
 | typ_lit : forall (G:ctx) (i5:i),
      uniq  G  ->
     typing G (e_lit i5) t_int
 | typ_var : forall (G:ctx) (x:var) (A:typ),
      uniq  G  ->
      binds  x A G  ->
     typing G (e_var_f x) A
 | typ_app : forall (G:ctx) (e1 e2:exp) (B A:typ),
     typing G e1 (t_arrow A B) ->
     typing G e2 A ->
     typing G (e_app e1 e2) B
 | typ_sub : forall (G:ctx) (e:exp) (A B:typ),
     typing G e B ->
     sub B A ->
     typing G (e_ann e A) A
 | typ_abs : forall (L:vars) (G:ctx) (A:typ) (e:exp) (B:typ),
      ( forall x , x \notin  L  -> typing  (( x ~ A )++ G )   ( open_exp_wrt_exp e (e_var_f x) )  B )  ->
     typing G (e_abs A e) (t_arrow A B)
 | typ_switch : forall (L:vars) (G:ctx) (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp) (C:typ),
     typing G e (t_or A B) ->
      ( forall x , x \notin  L  -> typing  (( x ~ A )++ G )   ( open_exp_wrt_exp e1 (e_var_f x) )  C )  ->
      ( forall x , x \notin  L  -> typing  (( x ~ B )++ G )   ( open_exp_wrt_exp e2 (e_var_f x) )  C )  ->
      DisjSpec  A   B  ->
     typing G (e_switch e A e1 B e2) C.

(* defns Reduction *)
Inductive step : exp -> exp -> Prop :=    (* defn step *)
 | step_appl : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     step e1 e1' ->
     step (e_app e1 e2) (e_app e1' e2)
 | step_appr : forall (v e e':exp),
     value v ->
     step e e' ->
     step (e_app v e) (e_app v e')
 | step_beta : forall (A:typ) (e v:exp),
     lc_exp (e_abs A e) ->
     value v ->
     step (e_app  ( (e_abs A e) )  v)  (open_exp_wrt_exp  e   v ) 
 | step_ann : forall (e:exp) (A:typ) (e':exp),
     step e e' ->
     step (e_ann e A) (e_ann e' A)
 | step_switch : forall (e:exp) (A:typ) (e1:exp) (B:typ) (e2 e':exp),
     lc_exp (e_switch e A e1 B e2) ->
     lc_exp (e_switch e A e1 B e2) ->
     step e e' ->
     step (e_switch e A e1 B e2) (e_switch e' A e1 B e2)
 | step_switchl : forall (v:exp) (A:typ) (e1:exp) (B:typ) (e2:exp) (C:typ),
     lc_exp (e_switch v A e1 B e2) ->
     lc_exp (e_switch v A e1 B e2) ->
     value v ->
     findtype v C ->
     sub C A ->
     step (e_switch v A e1 B e2)  (open_exp_wrt_exp  e1   v ) 
 | step_switchr : forall (v:exp) (A:typ) (e1:exp) (B:typ) (e2:exp) (C:typ),
     lc_exp (e_switch v A e1 B e2) ->
     lc_exp (e_switch v A e1 B e2) ->
     value v ->
     findtype v C ->
     sub C B ->
     step (e_switch v A e1 B e2)  (open_exp_wrt_exp  e2   v ) .


(** infrastructure *)
Hint Constructors value findtype ordinary sub typing step lc_exp : core.


