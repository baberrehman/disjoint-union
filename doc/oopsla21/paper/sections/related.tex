\section{Related Work}
\label{sec:related}

\bruno{Generally speaking I feel that either here, or in the overview, we
  should actually show concrete examples of other union elimination constructs,
in addition to having some text describing such constructs.}
\baber{I think we should have other union elimination constructs in overview.
       Because by doing so reader will have a better idea of our work
       comparison to available literature throughout the paper.
       If we put other constructs in related work, reader will only come to read
       them at the end.}

\begin{comment}
\begin{itemize}
	\item {Union Types    (discussing work on union types and elimination constructs for union types) <-- Need to coordinate with Ningning/Snow so that there’s not much overlap there. If the Overview discusses some of these in detail, the RW does not need to have much text in it.}
	\item {Overloading (more general work on overloading, including type classes, approaches to overloading based on intersection types, etc…)}
	\item{Disjointness and Disjoint Intersection Types}
\end{itemize}
\end{comment}

\paragraph{Union types}
\begin{comment}
Set-theoretic unions have sound theory and extensively studied in
mathematics. Set-theoretic unions correspond to union types or
disjoint union types in programming languages. Disjoint union types
are also called sum types or variants.  Constructors are explicitly
labeled in disjoint union types and expressions are manipulated using
corresponding labels. Few other interesting calculi (and this paper)
do not use labels and provide type-based union elimination.
%Developing
%a sound and deterministic union elimination construct for type-based
%union elimination have been a challenge in research community.
\end{comment}
Union types were first studied in the setting of programming languages by
\citet{macqueen1984ideal}, though the union elimination rule there is unsound in
standard call-by-value operational semantics as pointed out by
\cite{dunfield2003type}. Also, \citet{macqueen1984ideal} did not define dynamic
semantics. Later, union types have been studied in the literature in various
contexts. As discussed in \Cref{subsec:elimination},
\citet{pierce1991programming} and \cite{dunfield2014elaborating} support
single-branch elimination. However, as both calculi support intersection types,
with single-branch elimination the system can also be used to support form of
overloading. \cite{pierce1991programming} does not give the dynamic semantics.
On the other hand, \cite{dunfield2014elaborating} shows how to elaborate union
types into tagged union types. However, the result of such elaboration is
nondeterministic. For example, in her system, an Integer of type \lstinline{Int | Int}
can be non-deterministically tagged \lstinline{inj1} or
\lstinline{inj2}. Moreover, while \citet{dunfield2014elaborating} shows that
subtyping is not necessary for elaboration, it is not obvious how to generalize
elaboration to support subtyping relations such as
\lstinline{Student <: Person} without using the subtyping rule. If the
elaboration were generalized further to support such a subtyping relation, then
a student with type \lstinline{Student | Person} can also be tagged
non-deterministically.


% \citet{barbanera1995intersection} proposed
% two approaches for type preservation in a calculus with intersection and union
% types.
%However, their union elimination is same as last two and follow
%unrestricted union elimination.
\bruno{So you are arguying it is non-deterministic?
Again where can I find the semantics? Can you paste this on slack?}
\baber{I commented those lines from the paper. I think it is enough to say that
they target type preservation in their work.}

\ningning{the text regarding \citet{freeman1991refinement} feels unuseful. In
  particular, why we want to compare with their work?}

\citet{freeman1991refinement} studied union types along with intersection types
in setting of refinement types for ML. Main focus of their work is to infer
more precise types of expressions, which they call
refinement types. Their work is targeted to contribute for the types
in ML and not for the expressions. Therefore, they did not define
expressions and dynamic semantics. On the contrary, our work provides
a complete calculus with type sound dynamic semantics.
\bruno{and ... Do they have an elimination construct for unions?
  If so how is that related to our work?}.
\baber{I added few more lines in Freeman citation.}
\citet{hosoya2003xduce} studied union types
in XDuce programming language. XDuce offers a novel feature of
so-called regular expression types. Pattern matching can be on
expressions and types in XDuce.  Expressions are considered as special
cases of types. Although XDuce offers type-based switch construct,
it does not ensure disjointness. Thus cases can overlap and
reordering the cases may change the semantics of the program. CDuce
\cite{benzaken2003cduce} is an extension of XDuce. CDuce has improved
pattern matching but it also does not have disjoitness constraint and
follows firt-match policy.  \citet{fallside2001xml} studied union
types in markup language, but with a restriction of disjoint top-level
labels which is different from our work on
disjointness on types.\bruno{In other words, for the last work, the unions
are labelled (i.e. the cases are not based on types)?}
\baber{this seems right, this is mentioned in few references.
       But the documentation says order in which union types are created
       is significant and it seems like first match. Shall we drop this
       or it's worthy to mention Fallside citation?}
\baber{Upon further reading, I think he restricts creation of types like $[[Int \/ Int]]$
and $[[Int -> Bool \/ Int -> Bool]]$. }


\cite{frisch2002semantic} studied union types and intersection types
with semantic subtyping and provide theoretical basis for CDuce programming language.
However, their case expression (they call it \emph{match}) uses explicit
tags to select a particular branch. Whereas, we propose dynamic type-based
case construct.
\cite{castagna2005gentle} extended this work with type-based case construct
in the context of XDuce programming language. Main motivation of their
work is to elaborate the significance of semantics subtyping.
However, their underlying technique to select the branch in case construct
relies on negation types. We, on the other hand, use disjointness
and static type of the expression. \baber{they also use an extra variable.}
%\cite{frisch2008semantic}.
%\baber{more text.}
\citet{castagna2017gradual} studied
set-theoretic union types, intersection types and negation types
in gradual typing setting. They also propose a dynamic type-based
construct for set-theoretic union elimination which is closely
related to our work.
However, their underlying technique to select branches in case
expression is different from ours.
In particular, negation types play fundamental role in their
typing construct for the case expressions.
Whereas, our work relies on disjointness along with a notion of 
static types to to select a particular branch.
They also do not provide dynamic semantics for their source language.
Whereas, we provide a type sound dynamic semantics for \cal.
\baber{no variables in their case construct?}

\baber{below text will be removed for Castagna's work.}
\bruno{Castagna did alot of work
  on union types before this one, so I'm not sure why we are mentioning only this work
  of Castagna, instead of talking about previous work where the ideas were introduced.}
\baber{Castagna's work includes CDuce, which is mentioned. I added semantic subtyping
as well now. Should we add more Castagna's work? I think his above mentioned work 
is relevant to our work.}
They give a dynamic type-based cast for union elimination. But they do not
have disjointness constraint on case branches and they check the type
only for first case branch\bruno{Not a very good explanation: you get negated types for the branches}. 

Recently, \citet{muehlboeck2018empowering} gave a general framework for calculi
with intersection and union types. They illustrated the significane of
their framework using Ceylon programming language.
Objective of their work is to define a generic framework for the 
distributive subtyping of intersection and union types.
Although, they mentioned disjointness but they did not study disjointness
in their work. On the other hand, we formally study disjointness
along with a type-safe and deterministic type-based case construct for union elimination.
%They also studied disjointness in type-based case expressions.
\bruno{Very very weak: this makes it sound
  like that they already did something like our work: they did not. Their work was about
  subtyping relations with unions and intersections and distributivity rules. They briefly mentioned
  the switch construct of Ceylon and disjointness. But they have not studied the formal semantics
of such construct or formally defined disjointness.}
\baber{I updated the text.}

\paragraph{Occurrence Typing}
\bruno{This paragraph is very weak: it gives an incorrect explanation of occurrence typing, and it is not very comprehensive:
  it cover the two works I pointed out (for starters), but nothing else. We may not need to cover much more, but
  we need to make sure that we read some other work on occurrence typing to ensure that we are not missing something that is
closely related.}
Occurence typing or flow typing \cite{tobin2008design} specializes or refines 
the type of variable in type test. For example, code example below elaborates occurance typing.

\begin{lstlisting}
Int occurance(Int | String val) {
  if (isInt(val)) { return val+1; }
  else { return toInt(val)+2; }
}
\end{lstlisting}

\noindent Code example above takes an input variable \emph{val}
of type $[[Int \/ String]]$. 
\emph{If} condition checks if the \emph{val} is of $[[Int]]$ type.
If the condition succeeds, it is safe to assume that \emph{val} is of $[[Int]]$ type.
Function \emph{occurance} increments \emph{val} by 1 and returns in this case.
Otherwise, it is safe to assume that \emph{val} is of $[[String]]$ type.
Because type of \emph{val} is $[[Int \/ String]]$. If \emph{val} is not
of $[[Int]]$ type, then the other option to consider is only $[[String]]$ type.
We assume that incoming string is a valid representation of some integer
and \emph{toInt(val)} converts string to integer.
In this case, function \emph{occurance} increments \emph{val} by 2 and returns.
Note that occurance typing is specializing the type of
same existing variable \emph{val} in both cases above.
Motivation to study occurance typing was to introduce typing in untyped calculi,
which is a generic technique.
Whereas, we particularly studied type-based switch expression
with disjointness to preserve determinism.
Occurance typing is further studied by \cite{tobin2010logical}
which resulted into the development of Typed Racket.
\cite{castagna2019revisiting} studied occurance typing with more 
set-theoratic types such as intersection types and negation types.
He extended occurance typing to refine the type of
generic expressions, not just variables. He also studied occurance typing
together with gradual typing.

%\citet{castagna2019revisiting} recently studied
%occurence typing for set-theoretic types and allowed to have generic 
%expressions in switch expression.

\baber{will remove occurance typing text below.}
Occurence typing is limmited to have variables, whereas \cal
can have any arbitrary expression in switch expression
\bruno{Do not confuse occurrence typing with a switch expression.
  Occurrence typing is a technique that can be used when modelling case expressions for union types}.
Also, occurence typing comes with an
unrestricted typing construct for case expression
\bruno{Again you're confusing things: occurrence typing != case expression:
you could have our switch expression with occurrence typing,  but we chose not to.}.

\paragraph{Disjoint Intersection Types}
\citet{pottinger1980type} and \citet{coppo1981functional} initially
studied intersection types in programming languages
literature. Forsythe~\cite{reynolds1988preliminary} is the first 
programming language to have intersection types, but it did not
have union types.  Disjoint intersection types were first
studied by \citet{oliveira2016disjoint} in the $\lambda_{i}$ calculus
to give a coherent calculus for intersection types with a merge
operator. The notion of disjointness used in \cal, discussed in \Cref{sec:union},
is inspired by the notion of disjointness of $\lambda_{i}$. In essence in
disjointness in \cal is the dual notion: while in $\lambda_{i}$ two types
are disjoint if they only have top-like supertypes, in \cal two types
are disjoint if they only have bottom-like supertypes.

None of calculi with disjoint intersection types~\cite{} in the literature
includes union types. One interesting discovery of our work is that the
presence of both intersections and unions in a calculus can affect disjointness.
In particular, as we have seen in Section~\ref{sec:inter}, adding intersection types
required us to change disjointness. The notion of disjointness that was
derived from $\lambda_{i}$ stops working in the presence of intersection types.
Interestingly, a similar issue happens when union types are added to
a calculus with disjoint intersection types. If disjointness of two types $A$
and $B$ is defined to be that such types can only have top-like types,
then adding union types immediately breaks such definition.
For example, the types $[[Int]]$ and $[[Bool]]$ are disjoint but, with union
types, $[[Int \/ Bool]]$ is a common supertype that is not top-like.
We conjecture that, to add union types to disjoint intersection types,
we can use the following definition of disjointness:

\begin{definition}
\label{def:related:disj}
  A $*_s$ B $\Coloneqq$ $\forall$ C, \ $[[ordinary C]]$ \ $\rightarrow$ \ $\neg$ \ ($[[A <: C]]$ and $[[B <: C]]$).
\end{definition}

\noindent which is, in essence, the dual notion of the definition presented in
Section~\ref{sec:inter}. Under this definition $[[Int]]$ and $[[Bool]]$ would
be disjoint since we cannot find an common ordinary supertype (and $[[Int \/ Bool]]$
is a supertype, but it is not ordinary). Furthermore, there should be a
dual notion to LOS, capturing the greatest ordinary supertypes. Moreover,
if a calculus includes both disjoint switches and a merge operator,
then the two notions of disjointness must coexist in the calculus. 
This will be an interesting path of exploration for future work.

\paragraph{Overloading}
Union types also provide a kind of function overloading or ad-hoc
polymorphism using the switch and type-based case analysis. Programmer
may define the argument type to be union type of certain types. By
type-based case analysis programmer may choose to execute diffent code
for each specific type of input.  Intersection types have also been
studied for function overloading. For example a function with type
$[[Int -> Int /\ Bool -> Bool]]$ can take input values either of type
$[[Int]]$ or $[[Bool]]$.  It returns either $[[Int]]$ or $[[Bool]]$
depending upon the input type.  Function overloading has been studied
in detail in the literature by \cite{castagna1995calculus},
\cite{cardelli1985understanding}, \cite{stuckey2005theory} among
others.  \citet{wadler1989make} studied type classes for the
overloading of arithmetic operators.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% org-ref-default-bibliography: "../paper.bib"
%%% End: