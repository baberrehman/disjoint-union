\section{Related Work}
\label{sec:related}

\bruno{Generally speaking I feel that either here, or in the overview, we
  should actually show concrete examples of other union elimination constructs,
in addition to having some text describing such constructs.}
\baber{I think we should have other union elimination constructs in overview.
       Because by doing so reader will have a better idea of our work
       comparison to available literature throughout the paper.
       If we put other constructs in related work, reader will only come to read
       them at the end.}

\begin{comment}
\begin{itemize}
	\item {Union Types    (discussing work on union types and elimination constructs for union types) <-- Need to coordinate with Ningning/Snow so that there’s not much overlap there. If the Overview discusses some of these in detail, the RW does not need to have much text in it.}
	\item {Overloading (more general work on overloading, including type classes, approaches to overloading based on intersection types, etc…)}
	\item{Disjointness and Disjoint Intersection Types}
\end{itemize}
\end{comment}

\paragraph{Union Types}
\begin{comment}
Set-theoretic unions have sound theory and extensively studied in
mathematics. Set-theoretic unions correspond to union types or
disjoint union types in programming languages. Disjoint union types
are also called sum types or variants.  Constructors are explicitly
labeled in disjoint union types and expressions are manipulated using
corresponding labels. Few other interesting calculi (and this paper)
do not use labels and provide type-based union elimination.
%Developing
%a sound and deterministic union elimination construct for type-based
%union elimination have been a challenge in research community.
\end{comment}
Union types were first studied in the setting of programming languages
by \citet{macqueen1984ideal}. However, the union elimination rule
proposed by \citet{macqueen1984ideal} is unsound in standard call-by-value
operational semantics as pointed by \cite{dunfield2003type}.
Later on, union types have been studied
in the literature in various contexts. \citet{pierce1991programming}
studied union types with intersection types and polymorphism. But he
did not define dynamic semantics for his calculus. Also, Pierce
uses explicit tags in union elimination. On the contrary, we define
dynamic semantics for \cal and union elimination is without tags.
Precisely, we follow type-based union elimination.
\bruno{We need to be quite careful when making claims like this.
  For Pierce, since he has not defined the dynamic semantics you cannot say this. For MacQueen
  where can I find his semantics for union elimination?}.
\baber{I updated text for MacQeen and Pierce's work.}
\citet{barbanera1995intersection} proposed
two approaches for type preservation in a calculus with intersection and union
types.
%However, their union elimination is same as last two and follow
%unrestricted union elimination.
\bruno{So you are arguying it is non-deterministic?
Again where can I find the semantics? Can you paste this on slack?}
\baber{I commented those lines from the paper. I think it is enough to say that
they target type preservation in their work.}

\citet{freeman1991refinement} studied union types along with intersection types
in setting of refinement types for ML. Main focus of their work is to infer
more precise types of expressions, which they call
refinement types. Also, their work is targeted to contribute for the types
in ML and not for the expressions. Therefore, they did not define
expressions and dynamic semantics. On the contrary, our work provides
a complete calculus with dynamic semantics.
\bruno{and ... Do they have an elimination construct for unions?
  If so how is that related to our work?}.
\baber{I added few more lines in Freeman citation.}
\citet{hosoya2003xduce} studied union types
in XDuce programming language. XDuce offers a novel feature of
so-called regular expression types. Pattern matching can be on
expressions and types in XDuce.  Expressions are considered as special
cases of types. Although XDuce offers type-based switch construct,
it does not ensure disjointness. Thus cases can overlap and
reordering the cases may change the semantics of the program. CDuce
\cite{benzaken2003cduce} is an extension of XDuce. CDuce has improved
pattern matching but it also does not have disjoitness constraint and
follows firt-match policy.  \citet{fallside2001xml} studied union
types in markup language, but with a restriction of disjoint top-level
labels which is different from our work because we propose
disjointness on types.\bruno{In other words, for the last work, the unions
are labelled (i.e. the cases are not based on types)?}
\baber{this seems right, this is mentioned in few references.
       But the documentation says order in which union types are created
       is significant and it seems like first match. Shall we drop this
       or it's worthy to mention Fallside citation?}

\citet{dunfield2014elaborating} studied intersection and union
types with merge operator.
We do not have merge operator in \cal.
Her approach is to elaborate a source language with union types into a
target language with (tagged) sum types.
Her dynamic semantics for source language is nondeterministic.
For example, a program like:

\begin{lstlisting}[xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
Int nondeterministic(Int | Int val) {
  switch (val)
  case (is Int) {return 1;}
  case (is Int) {return 2;} 
}
\end{lstlisting}

\noindent may return either 1 or 2 in Dunfield's calculus.
\baber{She does not have an explicit case in source language.
Is it fine to show above code or should I show with merge operator?}
Whereas, such programs will not
type-check in \cal. Because \cal has a disjointness constraint on
types of branches in switch expression.
We propose a type-based union elimination construct which is
type-safe and deterministic.
Further, she did not add subtyping distributivity in her calculus.
We propose a variant of \cal with distributive subtyping in \Cref{sec:discussion}
which is more expressive than Dunfield's subtyping relation.
\bruno{You need to do better than this. I don't think the elimination
construct is unrestricted. You need to explain what that construct allows and disallows.}
\baber{Incoherent calculus. Enforce restriction on expression to be substituted
to have a single type for sound union elimination typing rule.
We acheive same by disjointness. No distributive subtyping, she mentions
it is challenging to add distributive subtyping.
She does not have dynamic semantics in source language.
Case in target language uses explicit tagging.}

\citet{castagna2017gradual} studied
set-theoretic union types in gradual typing setting\bruno{Castagna did alot of work
  on union types before this one, so I'm not sure why we are mentioning only this work
  of Castagna, instead of talking about previous work where the ideas were introduced.}. They
give a dynamic type-based cast for union elimination. But they do not
have disjointness constraint on case branches and they check the type
only for first case branch\bruno{Not a very good explanation: you get negated types for the branches}.
\baber{I will add semantic subtyping here.}
Union types are also studied with the notion of semantic subtyping 
\cite{frisch2002semantic,castagna2005gentle,frisch2008semantic}.
\baber{more text.}

Recently, \citet{muehlboeck2018empowering} gave a general framework for calculi
with intersection and union types. They illustrated the significane of
their framework using Ceylon programming language.
Objective of their work is to define a generic framework for the 
distributive subtyping of intersection and union types.
Although, they mentioned disjointness but they did not study disjointness
in their work. On the other hand, we formally study disjointness
along with a type-safe and deterministic type-based case construct for union elimination.
%They also studied disjointness in type-based case expressions.
\bruno{Very very weak: this makes it sound
  like that they already did something like our work: they did not. Their work was about
  subtyping relations with unions and intersections and distributivity rules. They briefly mentioned
  the switch construct of Ceylon and disjointness. But they have not studied the formal semantics
of such construct or formally defined disjointness.}
\baber{I updated the text.}

\paragraph{Occurrence Typing}
\bruno{This paragraph is very weak: it gives an incorrect explanation of occurrence typing, and it is not very comprehensive:
  it cover the two works I pointed out (for starters), but nothing else. We may not need to cover much more, but
  we need to make sure that we read some other work on occurrence typing to ensure that we are not missing something that is
closely related.}
Occurence typing or flow typing \citet{tobin2008design} specializes or refines 
the type of variable. For example, code example below elaborates occurance typing.

\begin{lstlisting}[xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
Int occurance(Int | String val) {
  if (isInt(val)) { return val+1; }
  else { return toInt(val)+2; }
}
\end{lstlisting}

\noindent Code example above takes an input variable \emph{val}
of type $[[Int \/ String]]$. 
\emph{If} condition checks if the \emph{val} is of $[[Int]]$ type.
If the condition succeeds, it is safe to assume that \emph{val} is of $[[Int]]$ type.
Function \emph{occurance} increments \emph{val} by 1 and returns.
Otherwise, it is safe to assume that \emph{val} is of $[[String]]$ type.
We assume that incoming string is a valid representation of some integer
and \emph{toInt(val)} converts string to integer.
In this case, function \emph{occurance} increments \emph{val} by 2 and returns.
Note that occurance typing is specializing the type of
same existing variable \emph{val} in both cases above.
Motivation to study occurance typing was to introduce typing in untyped calculi,
which is a generic technique.
Whereas, we particularly studied type-based switch expression
with disjointness to preserve determinism.
Occurance typing is further studied by \cite{tobin2010logical,castagna2019revisiting}
with more set-theoratic types such as intersection types.

%\citet{castagna2019revisiting} recently studied
%occurence typing for set-theoretic types and allowed to have generic 
%expressions in switch expression.

\baber{will remove occurance typing text below.}
Occurence typing is limmited to have variables, whereas \cal
can have any arbitrary expression in switch expression
\bruno{Do not confuse occurrence typing with a switch expression.
  Occurrence typing is a technique that can be used when modelling case expressions for union types}.
Also, occurence typing comes with an
unrestricted typing construct for case expression
\bruno{Again you're confusing things: occurrence typing != case expression:
you could have our switch expression with occurrence typing,  but we chose not to.}.

\paragraph{Disjoint Intersection Types}
\citet{pottinger1980type} and \citet{coppo1981functional} initially
studied intersection types in programming languages
literature. Forsythe~\cite{reynolds1988preliminary} is the first 
programming language to have intersection types, but it did not
have union types.  Disjoint intersection types were first
studied by \citet{oliveira2016disjoint} in the $\lambda_{i}$ calculus
to give a coherent calculus for intersection types with a merge
operator. The notion of disjointness used in \cal, discussed in \Cref{sec:union},
is inspired by the notion of disjointness of $\lambda_{i}$. In essence in
disjointness in \cal is the dual notion: while in $\lambda_{i}$ two types
are disjoint if they only have top-like supertypes, in \cal two types
are disjoint if they only have bottom-like supertypes.

None of calculi with disjoint intersection types~\cite{} in the literature
includes union types. One interesting discovery of our work is that the
presence of both intersections and unions in a calculus can affect disjointness.
In particular, as we have seen in Section~\ref{sec:inter}, adding intersection types
required us to change disjointness. The notion of disjointness that was
derived from $\lambda_{i}$ stops working in the presence of intersection types.
Interestingly, a similar issue happens when union types are added to
a calculus with disjoint intersection types. If disjointness of two types $A$
and $B$ is defined to be that such types can only have top-like types,
then adding union types immediately breaks such definition.
For example, the types $[[Int]]$ and $[[Bool]]$ are disjoint but, with union
types, $[[Int \/ Bool]]$ is a common supertype that is not top-like.
We conjecture that, to add union types to disjoint intersection types,
we can use the following definition of disjointness:

\begin{definition}
\label{def:related:disj}
  A $*_s$ B $\Coloneqq$ $\forall$ C, \ $[[ordinary C]]$ \ $\rightarrow$ \ $\neg$ \ ($[[A <: C]]$ and $[[B <: C]]$).
\end{definition}

\noindent which is, in essence, the dual notion of the definition presented in
Section~\ref{sec:inter}. Under this definition $[[Int]]$ and $[[Bool]]$ would
be disjoint since we cannot find an common ordinary supertype (and $[[Int \/ Bool]]$
is a supertype, but it is not ordinary). Furthermore, there should be a
dual notion to LOS, capturing the greatest ordinary supertypes. Moreover,
if a calculus includes both disjoint switches and a merge operator,
then the two notions of disjointness must coexist in the calculus. 
This will be an interesting path of exploration for future work.

\paragraph{Overloading}
Union types also provide a kind of function overloading or ad-hoc
polymorphism using the switch and type-based case analysis. Programmer
may define the argument type to be union type of certain types. By
type-based case analysis programmer may choose to execute diffent code
for each specific type of input.  Intersection types have also been
studied for function overloading. For example a function with type
$[[Int -> Int /\ Bool -> Bool]]$ can take input values either of type
$[[Int]]$ or $[[Bool]]$.  It returns either $[[Int]]$ or $[[Bool]]$
depending upon the input type.  Function overloading has been studied
in detail in the literature by \cite{castagna1995calculus},
\cite{cardelli1985understanding}, \cite{stuckey2005theory} among
others.  \citet{wadler1989make} studied type classes for the
overloading of arithmetic operators.
