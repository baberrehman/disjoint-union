\section{Related Work}
\label{sec:related}

\bruno{Generally speaking I feel that either here, or in the overview, we
  should actually show concrete examples of other union elimination constructs,
in addition to having some text describing such constructs.}

\begin{itemize}
	\item {Union Types    (discussing work on union types and elimination constructs for union types) <-- Need to coordinate with Ningning/Snow so that there’s not much overlap there. If the Overview discusses some of these in detail, the RW does not need to have much text in it.}
	\item {Overloading (more general work on overloading, including type classes, approaches to overloading based on intersection types, etc…)}
	\item{Disjointness and Disjoint Intersection Types}
\end{itemize}

\paragraph{Union Types}
\begin{comment}
Set-theoretic unions have sound theory and extensively studied in
mathematics. Set-theoretic unions correspond to union types or
disjoint union types in programming languages. Disjoint union types
are also called sum types or variants.  Constructors are explicitly
labeled in disjoint union types and expressions are manipulated using
corresponding labels. Few other interesting calculi (and this paper)
do not use labels and provide type-based union elimination.
%Developing
%a sound and deterministic union elimination construct for type-based
%union elimination have been a challenge in research community.
\end{comment}
Union types were first studied in the setting of programming languages
by \citet{macqueen1984ideal}. Later on, union types have been studied
in the literature in various contexts. \citep{pierce1991programming}
studied union types with intersection types and polymorphism. But he
did not define dynamic semantics for his calculus. Union elimination
is same in \citep{macqueen1984ideal} and \citep{pierce1991programming}
and is not deterministic\bruno{We need to be quite careful when making claims like this.
  For Pierce, since he has not defined the dynamic semantics you cannot say this. For MacQueen
  where can I find his semantics for union elimination?}.  \citet{barbanera1995intersection} proposed
two approaches for subject reduction in a calculus with union
types. However, their union elimination is same as last two and follow
unrestricted union elimination. \bruno{So you are arguying it is non-deterministic?
Again where can I find the semantics? Can you paste this on slack?}

\citet{freeman1991refinement} studied union types in setting of
refinement types for ML\bruno{and ... Do they have an elimination construct for unions?
  If so how is that related to our work?}.  \citet{hosoya2003xduce} studied union types
in XDuce programming language. XDuce offers a novel feature of
so-called regular expression types. Pattern matching can be on
expressions and types in XDuce.  Expressions are considered as special
cases of types. Although XDuce offers type-based switch construct,
it does not ensure disjointness. Thus cases can overlap and
reordering the cases may change the semantics of the program. CDuce
\cite{benzaken2003cduce} is an extension of XDuce. CDuce has improved
pattern matching but it also does not have disjoitness constraint and
follows firt-match policy.  \citet{fallside2001xml} studied union
types in markup language, but with a restriction of disjoint top-level
labels which is different from our work because we propose
disjointness on types.\bruno{In other words, for the last work, the unions
are labelled (i.e. the cases are not based on types)?}

\citet{dunfield2014elaborating} also studied intersection and union
types. Her approach is to elaborate a source language with union types into a
target language with (tagged) sum types. Our
work is different from her work because she used unrestricted union
elimination\bruno{You need to do better than this. I don't think the elimination
construct is unrestricted. You need to explain what that construct allows and disallows.}
in source language and sum types with explicit injectors
in target language.  \citet{castagna2017gradual} studied
set-theoretic union types in gradual typing setting\bruno{Castagna did alot of work
  on union types before this one, so I'm not sure why we are mentioning only this work
  of Castagna, instead of talking about previous work where the ideas were introduced.}. They
give a dynamic type-based cast for union elimination. But they do not
have disjointness constraint on case branches and they check the type
only for first case branch\bruno{Not a very good explanation: you get negated types for the branches}.
Recently, \citet{muehlboeck2018empowering} gave a general framework of a calculi
with intersection and union types. They illustrated the significane of
their framework using Ceylon programming language.  They also studied
disjointness in type-based case expressions.\bruno{Very very weak: this makes it sound
  like that they already did something like our work: they did not. Their work was about
  subtyping relations with unions and intersections and distributivity rules. They briefly mentioned
  the switch construct of Ceylon and disjointness. But they have not studied the formal semantics
of such construct or formally defined disjointness.}

\paragraph{Occurrence Typing}
\bruno{This paragraph is very weak: it gives an incorrect explanation of occurrence typing, and it is not very comprehensive:
  it cover the two works I pointed out (for starters), but nothing else. We may not need to cover much more, but
  we need to make sure that we read some other work on occurrence typing to ensure that we are not missing something that is
closely related.}
Occurence typing or flow typing \citet{tobin2008design} specialize or refine the type of variable in different
case branches. Occurence typing is limmited to have variables in switch expression, whereas \cal
can have any arbitrary expression in switch expression\bruno{Do not confuse occurrence typing with a switch expression.
  Occurrence typing is a technique that can be used when modelling case expressions for union types}.
Also, occurence typing comes with an
unrestricted typing construct for case expression\bruno{Again you're confusing things: occurrence typing != case expression:
you could have our switch expression with occurrence typing,  but we chose not to.}. \citet{castagna2019revisiting} recently studied
occurence typing for set-theoretic types and allowed to have generic expressions in switch expression.

\paragraph{Disjoint Intersection Types}
\citet{pottinger1980type} and \citet{coppo1981functional} initially
studied intersection types in programming languages
literature. Forsythe~\cite{reynolds1988preliminary} is the first 
programming language to have intersection types, but it did not
have union types.  Disjoint intersection types were first
studied by \citet{oliveira2016disjoint} in the $\lambda_{i}$ calculus
to give a coherent calculus for intersection types with a merge
operator. The notion of disjointness used in \cal, discussed in \Cref{sec:union},
is inspired by the notion of disjointness of $\lambda_{i}$. In essence in
disjointness in \cal is the dual notion: while in $\lambda_{i}$ two types
are disjoint if they only have top-like supertypes, in \cal two types
are disjoint if they only have bottom-like supertypes.

None of calculi with disjoint intersection types~\cite{} in the literature
includes union types. One interesting discovery of our work is that the
presence of both intersections and unions in a calculus can affect disjointness.
In particular, as we have seen in Section~\ref{sec:inter}, adding intersection types
required us to change disjointness. The notion of disjointness that was
derived from $\lambda_{i}$ stops working in the presence of intersection types.
Interestingly, a similar issue happens when union types are added to
a calculus with disjoint intersection types. If disjointness of two types $A$
and $B$ is defined to be that such types can only have top-like types,
then adding union types immediately breaks such definition.
For example, the types $[[Int]]$ and $[[Bool]]$ are disjoint but, with union
types, $[[Int \/ Bool]]$ is a common supertype that is not top-like.
We conjecture that, to add union types to disjoint intersection types,
we can use the following definition of disjointness:

\begin{definition}
\label{def:inter:disj}
  A $*_s$ B $\Coloneqq$ $\forall$ C, \ $[[ordinary C]]$ \ $\rightarrow$ \ $\neg$ \ ($[[A <: C]]$ and $[[B <: C]]$).
\end{definition}

\noindent which is, in essence, the dual notion of the definition presented in
Section~\ref{sec:inter}. Under this definition $[[Int]]$ and $[[Bool]]$ would
be disjoint since we cannot find an common ordinary supertype (and $[[Int \/ Bool]]$
is a supertype, but it is not ordinary). Furthermore, there should be a
dual notion to LOS, capturing the greatest ordinary supertypes. Moreover,
if a calculus includes both disjoint switches and a merge operator,
then the two notions of disjointness must coexist in the calculus. 
This will be an interesting path of exploration for future work.

\paragraph{Overloading}
Union types also provide a kind of function overloading or ad-hoc
polymorphism using the switch and type-based case analysis. Programmer
may define the argument type to be union type of certain types. By
type-based case analysis programmer may choose to execute diffent code
for each specific type of input.  Intersection types have also been
studied for function overloading. For example a function with type
$[[Int -> Int /\ Bool -> Bool]]$ can take input values either of type
$[[Int]]$ or $[[Bool]]$.  It returns either $[[Int]]$ or $[[Bool]]$
depending upon the input type.  Function overloading has been studied
in detail in the literature by \cite{castagna1995calculus},
\cite{cardelli1985understanding}, \cite{stuckey2005theory} among
others.  \citet{wadler1989make} studied type classes for the
overloading of arithmetic operators.
