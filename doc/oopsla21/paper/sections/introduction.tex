\section{Introduction}
\label{sec:intro}

Most programming languages support some mechanism to express terms
with alternative types. Algol 68~\cite{} included a form of
\emph{tagged} unions for this purpose. With tagged unions
an explicit tag is needed to distinguish between different cases in the
union. Such an approach has been adopted by functional languages, like Haskell, ML, or
OCaml, which allow tagged unions (or sum types~\cite{}) in some form.
Typically by using either \emph{algebraic datatypes}~\cite{} or \emph{variant
  types}~\cite{} (in the case of OCaml).  Languages like C or C++ support \emph{untagged} union types where
values of the alternative types are simply stored at the same memory
location. However, there is no checking of types when accessing values of
such untagged types. Thus, it is up to the programmer to ensure that the proper
values are accessed correctly in different contexts. Otherwise the
program may crash by accessing the value at the incorrect type.
Modern OOP languages, such as Scala~\cite{}, Flow~\cite{},
TypeScript~\cite{} or Ceylon~\cite{} support a form
of untagged union types, which is inspired by 

algebraic datatypes 

Union types were introduced by 

Union types allow expressing terms with alternative types.


Several forms of
union types have been investigated in the research literature, and
union types are nowadays a common feature in many modern programming
languages.

%The Ceylon programming language is interesting in that it
%supports union types, with an innovative elimination construct that has
%not been previously studied in the rese
This paper investigates a particular formulation of union types,
inpired by the Ceylon programming language, with an elimination
construct that enables case analysis (or switches) on types.  The
interesting aspect of such construct is that each clause must operate
on \emph{disjoint} types. By using such elimination construct, it is
possible to ensure that all possible cases are
handled and that none of the cases overlap. In turn, this means that
the order of the cases does not matter and reordering the cases has no
impact on the semantics, which can aid program undertanding and
refactoring.

While implemented in the Ceylon language, such construct
with disjoint switches has not been formally studied in the research
literature, although a related notion of disjointness has been studied
in the context of \emph{disjoint intersection types}.

We study union types
with disjoint switches formally and in a language independent way.
We present the \emph{union calculus} (\cal) that includes disjoint
switches and prove several results, including type soundness and
determinism. The notion of disjointness in \cal is interesting in that
it is in essence the dual notion of disjointness for intersection types. 

However, there are challenges that arize for disjointness when combining
union and intersection types.

We also study several extensions, including intersection
types and distributive subtyping and show that such extensions retain
all the desired properties. All the results about \cal and its
extensions have been formalized in the Coq theorem prover.

In summary, the contributions of this paper are:

\begin{itemize}
\item Contrib 1
\end{itemize}



%\begin{align*}
%&Isomorphic & A \sim B & ::= [[A <: B]] \wedge [[B <: A]]
%\end{align*}


%\begin{align*}
%&BottomLikeSpec & C & ::= (\forall A ~ B, ~ [[A /\ B]] \sim C \rightarrow \neg ( [[ A <: B ]] ) \wedge \neg ( [[ B <: A ]] )) \vee ([[C <: Bot]])
%\end{align*}

%\begin{align*}
%&DisjSpec & A * B & ::= \forall C, [[C <: A]] \wedge [[C <: B]] \rightarrow  \rfloor [[C]] \lfloor
%\end{align*}
