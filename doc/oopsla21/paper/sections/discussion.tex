\section{Discussion}
\label{sec:discussion}
In this section we discuss some extensions and provide a comparision with the approach
adopted in Ceylon.

\subsection{A More General Subtyping Rule for Bottom  Types}
\label{sec:inter:refactoring}
As discussed in Section~\ref{sec:inter:disj}, Ceylon includes the following subtyping rule:

\begin{center}
\drule[]{s-disj}
\end{center}

%One property of Ceylon programming language ~\cite{} is that all \emph{bottom-like} types are 
%subtype of $[[Bot]]$ type.
\noindent It is possible to support, and in fact generalize, such as rule in \name. The idea is to
employ our definition of lowest ordinary subtypes, and add the following rule 
%This property also holds in \cal presented in \Cref{sec:union}. But this property does not
%hold in \cal with intersection types presented in \Cref{sec:inter} because we updated
%disjointness definition. We add following novel subtyping rule in subtyping of
%\Cref{sec:inter} to have this property
in \cal with intersection types:

\begin{center}
\drule[]{s-los}
\end{center}

\noindent \Rref{s-los} is an interesting addition in subtyping of \cal with intersection types.
It says that if LOS returns the empty set for some type $[[A]]$, then $[[A]]$
is a subtype of all types. In other words, such type behaves like a \emph{bottom-like} type.
Such rule generalizes the \rref{s-disj}
employed in Ceylon, since when $[[A]]$ is an intersection type of two
disjoint types, we get the empty set.
%Since $[[findsubtypes Int /\ A -> B]]$ returns empty set,
%therefor \rref{s-disj} makes $[[Int /\ A -> B]]$ subtype of all types.
Moreover, adding \rref{s-los} makes \rref{s-bot} redundant as well, since the LOS for
the bottom type is also the empty set. Therefore \rref{s-bot} can safely be dropped without any
any loss of expressiveness. It is trivial to prove a lemma which says that $[[Bot]]$ type is
subtype of all types. We drop \rref{s-bot} from the calculus discussed in \Cref{sec:inter}
and prove \Cref{lemma:discussion:bls} to show this property instead:

\begin{lemma}[Bottom Type Least Subtype]
  $[[Bot <: A]]$.
\label{lemma:discussion:bls}
\end{lemma}

\noindent A similar lemma can be proved to show that disjoint types are bottom-like
(as in \rref{s-disj}), when \rref{s-los} is added to subtyping:

\begin{lemma}[Disjont Intersections are Bottom-Like]
  If $[[A *s B]]$ then $[[A /\ B <: Bot]]$.
\label{lemma:discussion:disjoint-types}
\end{lemma}

\noindent The use of \rref{s-los} instead of \rref{s-disj} also has
the advantage that it does not create a mutual dependency between
disjointness and subtyping. We can have the definition of
disjointness, which depends only on subtyping and ordinary types, and
the definition of subtyping, which depends on LOS but not on
disjointness.
%Nevertheless, like \rref{s-disj}, \rref{s-los} would not be an appropriate
%rule in calculi with a merge operator for the reasons discussed in Section~\ref{}.

We have formalized and proved all the metatheory, including
type-soundness, transitivity of subtyping, soundness and completeness
of disjointness and determinism for a variant of \name with
intersection types and \rref{s-los}.

\subsection{Subtyping Distributivity}
\label{sec:inter:dist}

Another interesting extension is to add distributive subtyping to \cal.
Ceylon~\cite{muehlboeck2018empowering} employs an enriched 
distributive subtyping relation that is based on the 
B+ logic~\cite{routley1972semantics,van2000minimal}
\bruno{ask Snow about this reference?}.
Distributive subtyping is more expressive and accomodates more programs than what we discussed in
\Cref{sec:union,sec:inter}. Here we add distributive subtyping in the variant of \cal with
intersection types. 

\subsubsection*{Distributive subtyping relation.}
\Cref{fig:discussion:ds} shows a declarative version of distributive subtyping for
\cal with intersection types.
This subtyping relation is declarative as it includes axioms for subtyping reflexivity (\rref{ds-refl}) and
subtyping transitivity (\rref{ds-trans}). \Rref{ds-top,ds-btm,ds-int,ds-arrow,ds-ora} have been
discussed in \Cref{sec:union}. \Rref{ds-anda} has been discussed in \Cref{sec:inter}.
\Rref{ds-orb,ds-orc} state that a subpart of a union type is a subtype of whole union type.
\Rref{ds-andb,ds-andc} state that intersection type $[[A1 /\ A2]]$ is a subtype of both $[[A1]]$
and $[[A2]]$ separately.\bruno{Snow can't we drop some of the distributivity rules? Some of them
are redundant, right?}
\baber{We dropped 3 rules in figure 6.}

\Rref{ds-distarr} distributes function types over intersection types.
It states that $[[(A -> B1) /\ (A -> B2)]]$ type is subtype of
$[[A -> (B1 /\ B2)]]$ type.
\Rref{ds-distarru} states that $[[(A1 -> B) /\ (A2 -> B)]]$ is subtype of
$[[(A1 \/ A2) -> B]]$ type.
\Rref{ds-distor} distributes intersection types over union types.

\subsubsection*{An example of distributive subtyping in Ceylon.}
We show the use of distributive subtyping with following Ceylon code snippet:

\begin{lstlisting}
void do(<Integer & String> | Boolean val) {
  //do something
}
\end{lstlisting}

\noindent The function \emph{do} in above code snippet takes input value of type 
$[[(Int /\ String) \/ Bool]]$. With distributivity of unions over intersections
(and vice-versa) the type $[[(Int \/ Bool) /\ (String \/ Bool)]]$ is a
subtype of $[[(Int /\ String) \/ Bool]]$.
But our standard subtyping relation discussed in \Cref{sec:union,sec:inter}
fails to identify this subtyping relation.
As a result we cannot pass a
value of type $[[(Int \/ Bool) /\ (String \/ Bool)]]$ to the function
\emph{do}: we get an error if we try to do that.
Distributive subtyping allows type-checking such programs.
With distributive subtyping, following Ceylon application type-checks:

\begin{lstlisting}
val <Integer | Boolean> & <String | Boolean> x = true;
do(x);
\end{lstlisting}

\noindent In particular, \rref{ds-distor} allows this specific program to type-check.
While the above function application does not type-check without
subtyping distributivity.
Therefore, distributive subtyping is more expressive than standard subtyping
discussed in \Cref{sec:union,sec:inter}.


\subsubsection*{\name extension with distributivity.}
We have studied a variant of \name with intersection types and subtyping distributivity.
All the metatheory for this variant is proved in Coq. The variant preserves
type-soundness, soundness and completeness of disjointness and determinism.
Additionaly, subtyping distributivity
does not affect the disjointness definitions (both declarative and algorithmic)
and these definitions are just the same as those discussed in \Cref{sec:inter}.

\begin{figure}[t]
  %\centering
  \drules[ds]{$ [[A <<: B ]] $}{Declarative Subtyping}{refl,trans,top,btm,int,arrow,ora,orb,orc,anda,andb,andc,distarr,distarru,distor}
  \caption{Declarative Subtyping}
  \label{fig:discussion:ds}
\end{figure}

\subsection{Disjointness in Ceylon}
\label{sec:discussion:ceylon}

In this subsection
we briefly compare the disjointness provided by Ceylon with our disjointness definition.
\begin{comment}
\ningning{A similar example is used in the overview. Maybe we want to be
  consistent with the examples.}
\baber{I will make this example consistent with the example in overview. But I suppose
  I should be using Ceylon syntax in this section.}

\begin{figure}[t]
\begin{lstlisting}[xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
// Student <: Person
// speak function will not type check
void speak(Person | Student val) {
  switch (val)
  case (is Person) {print("person speaks");}
  case (is Student) {print("student speaks");} 
}
\end{lstlisting}
\caption{Ceylon disjointness code example.}
\label{discussion:list:ceylon}
\end{figure}

\noindent The function \emph{speak} in \Cref{discussion:list:ceylon} 
will not type check in Ceylon. Because \emph{Person} and
\emph{Student} are not disjoint types. \emph{Person} and \emph{Student} both have a common
subtype which is \emph{Student}. \cal will also reject such programs.
\end{comment}
A difference between the disjointness in Ceylon and \cal is that
Ceylon does not provide
a formal disjointness definition.
The Ceylon specification does, however, provide English descriptions
for disjointness. 

We compare some of those descriptions with
the disjointness definition in \cal. Ceylon has 14 different points describing
disjointness, but some of these are quite language specific. For instance, talking
about disjointness for some of important classes and primitive types in Ceylon.
We pick 5 points next which are quite general, and they can be related to our
own definitions of disjointness. The following 5 points are copied from the
Ceylon specification\footnote{\url{https://ceylon-lang.org/documentation/1.3/spec/html_single/}}.
According to the specification, two types X and Y are disjoint when:

\begin{enumerate}
  \item{X is a subtype of a type A and Y is a subtype of a type B, where A and B are distinct cases of an enumerated type}
  \item{X and Y are both classes and X is not a subclass of Y and Y is not a subclass of X}
  \item{X is a union type $[[A \/ B]]$ and both Y and A are disjoint and Y and B are disjoint}
  \item{X is an enumerated type with cases A1|A2|... and for every case Ai of X, Y and Ai are disjoint}
  \item{X is an intersection type $[[A/\B]]$ and either Y and A are disjoint or Y and B are disjoint}
\end{enumerate}
\bruno{Did you cut some text in point 5? You finssh the sentence with ``or''.}
\baber{I droppped or, it refers to next point in documentation
which is about generic type and intersections.}

\noindent All these points are trivially covered by our formal disjointness \Cref{def:inter:disj}.
\bruno{Since there are only 5 points, instead of just picking 2 points next, talk about all
the 5 points and explain how they relate. You should give a few more details next.}
\baber{I think we should drop point 1 and 4. They are not directly related to our calculus.
or shall we relate enumerated types with intersection types in our calculus? But if we do that
then there is point 3 that talks about union types separately.}
For example, (2) is one specific case of \Cref{def:inter:disj}.\bruno{I guess what you may
  want to say is that we can prove something like: $not (A <: B)$ and $not (B <: A)$ implies $A * B$?
You can make a stronger point by proving this lemma and show it here.}
\baber{I doubt if this property hold in our calculus. For example,
A = (Char $\wedge$ Bool) $\vee$ Int, B = (String $\wedge$ Float) $\vee$ Int.
A and B are not subtypes of each other.
But they do share an ordinary subtype Int.
I think this is the counter example, considering Float and Int are non-overlapping types?}
When both types $[[A]]$ and
$[[B]]$ are not subtypes of each other, they naturally do not share any common ordinary subtype.
\baber{I added text for point 3 below.}
Point (3) is essentially the algorithmic
rule for union disjointness (\rref{ad-orl} in Section~\ref{sec:union}) in \cal.
Point (5) is also a specific case of \Cref{def:inter:disj}.
When a component type (either $[[A]]$ or $[[B]]$) of an intersection type $[[A /\ B]]$
is disjoint to some type $[[C]]$. Then that specific
component type (either $[[A]]$ or $[[B]]$) and type $[[C]]$ 
do not share any common ordinary subtype.
If a component type of intersection type do not share ordinary subtype
with some type, then naturally complete intersection type do not share
ordinary subtype with that type. 
Therefore, $[[C]]$ is disjoint to $[[A /\ B]]$ if it is disjoint to either of
the component type in intersection type.
For example, type $[[Int /\ Top]]$ is disjoint to type $[[Bool]]$.
Because first component of $[[Int /\ Top]]$, which is $[[Int]]$ in this case,
is disjoint to $[[Bool]]$.
Following \Cref{def:inter:disj}, $[[Int]]$ and $[[Bool]]$ do not share any
ordinary subtype and so $[[Int /\ Top]]$ and $[[Bool]]$.
We show this property with following two lemmas in \name:

\begin{lemma}[Left Component Type in Intersection Type Disjoint]
  If $[[A *s C]]$ then $[[(A /\ B) *s C]]$.
\label{lemma:discussion:comp:left:inter}
\end{lemma}

\begin{lemma}[Right Component Type in Intersection Type Disjoint]
  If $[[B *s C]]$ then $[[(A /\ B) *s C]]$.
\label{lemma:discussion:comp:right:inter}
\end{lemma}