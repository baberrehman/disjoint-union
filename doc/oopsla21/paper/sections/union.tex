\section{\dut}
\label{sec:union}

This section discusses a simple version of disjoint union types without intersection types. We propose a type-safe, coherent, sound, complete and deterministic calculus for disjoint union types in this section. Subtyping relation is standard for a system with union types. Calculus discussed in this section and subsequent sections is named as \cal.

%%%%%%%%%%%%%%%%%%%%%
%% Syntax
%%%%%%%%%%%%%%%%%%%%%

\subsection{Syntax}
\label{sec:union:syntax}
\Cref{fig:union:syntax} shows the syntax for \cal. Metavariables $[[A]]$ and $[[B]]$ range over types.
Types include top ($[[Top]]$), bottom ($[[Bot]]$), function ($[[A -> B]]$) and union ($[[A \/ B]]$) types.
Metavariable $[[e]]$ ranges over program expressions. Expressions include variables ($[[x]]$), natural numbers ($[[i]]$), type annotations ($[[e:A]]$), lambda abstractions ($[[\x.e]]$), applications ($[[e1 e2]]$) and a novel typeof ($[[typeof e as A e1 B e2]]$) expression. \Typeof expression is like a case expression and evaluates a specific branch by matching the type. Details of \typeof expression will further be discussed in typing and operational semantics sections.

Metavariable $[[p]]$ ranges over partial expressions which are also referred as partial values.
It consists of natural numbers $[[i]]$ and annotated lambda expressions $[[\x.e : A -> B]]$.
Values are annotated partial expressions. Metavariable $[[v]]$ ranges over values. It is important to
note that $[[i]]$ is not a value in this calculus, instead $[[i:Int]]$ is a value.
Context ($[[G]]$) can either be empty or contains type bindings of variables and associated types. 

\begin{figure}[t]
  \begin{small}
    \centering
    \begin{tabular}{lrcl} \toprule
      Types & $[[A]], [[B]]$ & $\Coloneqq$ & $ [[Top]] \mid [[Bot]] \mid [[Int]] \mid [[A -> B]] \mid [[A \/ B]] $ \\
      Expr & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[e:A]] \mid [[\x.e]] \mid [[e1 e2]] \mid [[typeof e as A e1 B e2]]$\\
      PExpr & $[[p]]$ & $\Coloneqq$ & $[[i]] \mid [[\x.e : A -> B]] $\\
      Value & $[[v]]$ & $\Coloneqq$ & $[[p:A]]$\\
      Context & $[[G]]$ & $\Coloneqq$ & $ empty \mid [[G , x : A]]$ \\
      \bottomrule
    \end{tabular}
  \end{small}\\
  \caption{Syntax for \dut.}
  \label{fig:union:syntax}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%
%% Subtyping
%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtyping}
\label{sec:union:sub}
Algorithmic subtyping rules for \dut are shown in \Cref{fig:union:sub}. Subtyping rules are standard.
\Rref{s-top} states that all types are subtypes of $[[Top]]$. \Rref{s-bot} states that $[[Bot]]$ is
subtype of all types. \Rref{s-int, s-arrow} are standard rules for integers and functions respectively.
Functions are contravariant in input types and covariant in output types. \Rref{s-ora, s-orb, s-orc} are
standard subtyping rules for union types. Union type of two types $A1$ and $A2$ is a subtype of another
type $A$ if both $A1$ and $A2$ are subtype of $A$, as stated in \rref{s-ora}. \Rref{s-orb, s-orc} state
that if a type is subtype of part of union type, then it is subtype of whole union type.

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[s]{$ [[A <: B ]] $}{Algorithmic Subtyping}{top, bot, int, arrow, ora, orb, orc}
  \end{small}
  \caption{Subtyping for \dut.}
  \label{fig:union:sub}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%
%% Typing
%%%%%%%%%%%%%%%%%%%%%
\subsection{Typing}
\label{sec:union:typ}
\Cref{fig:union:typ} shows typing rules for \dut. We adopt bidirectional typing in our calculus.
Two typing modes are opted in bidirectional typing. Inference mode ($[[=>]]$) and check mode ($[[<=]]$).
In inference mode, type of an expression $[[e]]$ is inferred or calculated based upon certain information in
the given context. While in check mode, an expression $[[e]]$ is checked against a given type $[[A]]$.
Typing rules are standard except of \rref{typ-typeof}.
An integer expression $[[i]]$ infers type $[[Int]]$ as stated in \rref{typ-int}.
\Rref{typ-var} states that a variable infers type $[[A]]$ if it has type $[[A]]$ in the context.
\Rref{typ-ann} states if an expression $[[e]]$ checks against type $[[A]]$, then the annotated expression
$[[e:A]]$ infers type $[[A]]$. 

\Rref{typ-app} type checks a function application. Expressions $[[e1]]$
has to be a function expression and expression $[[e2]]$ has to check against input type of $[[e1]]$.
An important point to notice in \rref{typ-app} is $[[e1]]$ infers type $[[A -> B]]$. This may look weird
at the very first glance because lamda expressions ($[[\x.e]]$) are not annotated in program expressions 
$[[e]]$ and it seems not possible for lambda expressions to infer its type.
To answer this question, we emphasize the use of partial expressions $[[p]]$ and values $[[v]]$.
Lambda expression is annotated in $[[p]]$ and so in $[[v]]$ because values are defined as annotated
partial expressions. \baber{more discussion on this in operational semantics.}

\Rref{typ-sub} is the subsumption rule. It states that an expression $[[e]]$ can be checked 
against the supertypes of its inferred type. 
\Rref{typ-abs} is the standard introduction rule for lambda expressions. To check a
lambda expression $[[\x.e]]$ against type $[[A -> B]]$, it is sufficient to check lambda body $[[e]]$
against the output type $[[B]]$ in an extended context with parameter $[[x]]$ of input type $[[A]]$.
\Rref{typ-typeof} is novel typing rule to type check \typeof expressions. Four conditions are necessary
for typing \typeof expressions. Very last condition ($[[A *s B]]$) ensures that branches in case 
expressions are always disjoint. Overlapping branches in case expressions lead to non-deterministic
and incoherent results. Disjointness guarrantees determinism and coherence for case expressions.
Rest of the conditions are standard for calculus with union types and case expressions and have been
studied in various calculi (\baber{reference to calculi}).

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[typ]{$ [[G |- e dirflag A]] $}{Bidirectional Typing}{int, var, ann, app, sub, abs, typeof}
  \end{small}
  \caption{Typing for \dut.}
  \label{fig:union:typ}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%
%% Operations Semantics
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Operational Semantics}
\label{sec:union:os}
Dynamics of \cal are defined by small-steps operational semantics strategy. \Cref{fig:union:os} shows
operational semantics of \cal. Before going into the details of operational semantics, it is important
to recall partial expressions and values. An integer expression $[[i]]$ or a lambda expression $[[\x.e]]$
are not values unless annotated. Lambda expression has to be dually annotated to fulfill the criteria to
be a value. Operational semantics follow call-by-value evaluation strategy.

\Rref{step-int} annotates integer expressions and makes them values. \Rref{step-appl} reduces left expression
from an application unless it becomes a value. \Rref{step-appr} works only if left expression from an
application is already reduced to value. It reduces right expression from application to a value.
\Rref{step-beta} is the beta reduction. It applies dually annotated lambda expression 
$[[\x.e : A1 -> B1 : A2 -> B2]]$ to input value $[[p:C]]$. Substitution replaces free occurances of variable
$[[x]]$ with value $[[p:A1]]$. Note that annotation of partial value $[[p]]$ has changed to $[[A1]]$ from 
$[[C]]$ in substitution. This is to keep the most specific type in annotation. Substituted expression is also
annotated with both of the output types from annotated lambda expression. \baber{More details.}

\Rref{step-absbeta} deals with the simple lambda expressions of the form $[[\x.e]]$ as input to function.
It follows same as \rref{step-beta} except that both of the input types are kept with $[[\x.e]]$ during
substitution i.e $[[\x.e:A2:A1]]$. \Rref{step-ann} reduces annotated expression only if it is not a value
and $[[e]]$ reduces to some $[[e']]$. \Rref{step-rmann} drops inner annotation. \Rref{step-lamann} adds one
more type annotation with lambda expressions having single type annotation to make them values.
\Rref{step-typeof, step-typeofl, step-typeofr} deal with the reduction of \typeof expressions.

\Rref{step-typeof} reduces the case expression $[[e]]$ unless it becomes a value of the form $[[p:D]]$.
\Rref{step-typeofl} evaluates left branch of the \typeof expression if type of $[[e]]$ is subtype
of type of left branch.
\Rref{step-typeofr} evaluates right branch of the \typeof expression if type of $[[e]]$ is subtype
of type of right branch.
It is important to note that types of left and right branches of \typeof expression cannot overlap
because of disjoitness contraint in typing. Programs with overlapping types in branches of \typeof
expression will not type check in \cal. FindType relation calculates the type of partial expressions
and is shown in lower part of \Cref{fig:union:os}.

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[step]{$[[e --> e']]$}{Operational Semantics}{int, appl, appr, beta, absbeta, ann, rmann, lamann, typeof, typeofl, typeofr}
  \end{small}
  \begin{small}
    \centering
    \drules[findtype]{$[[findtype p A]]$}{FindType}{int, arrow}
  \end{small}
  \caption{Operational semantics for \dut and FindType.}
  \label{fig:union:os}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%
%% Disjointness
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disjointness}
\label{sec:union:disj}
In this section we discuss in detail the notion of disjointness for union types and case expressions.
Idea is borrowed from \baber{disjoint intersection types reference.} Two types in \cal are disjoint
only if they do not share any common subtype. This disjointness is dual to 
\baber{disjoint intersection types reference.} in which two types are disjoint only if they do not
share any common supertype or the common supertype is top-like. Since we also have $[[Bot]]$ type
in \cal, which will always be the common subtype of any two types. So, in \cal two types are
disjoint only if the common subtype is bottom-like. Bottom-like types are shown in
\Cref{fig:union:bl}. $[[Bot]]$ is bottom-like type (\rref{bl-bot}) and union of two bottom-like
types is also bottom-like (\rref{bl-or}). 
Formal definition for disjoint specifications is given as:

\begin{definition}
\label{def:union:disj}
  A $*_s$ B $\Coloneqq$ $\forall$ C, $[[C <: A]]$ $\wedge$ $[[C <: B]]$ $\rightarrow$ $[[botLike C]]$
\end{definition}

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[bl]{$[[botLike A]]$}{Bottom-Like Types}{bot, or}
  \end{small}
  \caption{Bottom-Like types for \dut.}
  \label{fig:union:bl}
\end{figure}

\noindent We illustrate specifications given in \Cref{def:union:disj} on few examples. 
$[[Int]]$ and $[[Int]]$ are not disjoint types because they share a common subtype $[[Int]]$ which
is not bottom-like. Similarly $[[Int]]$ and $[[Top]]$ are not disjoint types. $[[Int]]$ and $[[A -> B]]$
are disjoint types. Common subtypes of $[[Int]]$ and $[[A -> B]]$ include $[[Bot]]$ and union of 
$[[Bot]]$ types. $[[Bot]]$ and union of $[[Bot]]$ types are bottom-like types which make $[[Int]]$ and 
$[[A -> B]]$ disjoint types as per \Cref{def:union:disj}.

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[ad]{$[[A * B]]$}{Algorithmic Disjointness}{btmr, btml, intl, intr, orl, orr}
  \end{small}
  \caption{Algorithmic Disjointness for \dut.}
  \label{fig:union:ad}
\end{figure}

\noindent \Cref{fig:union:ad} shows an algorithmic version of disjointness.
\Rref{ad-btmr, ad-btml} state that $[[Bot]]$ is disjoint to every type.
\Rref{ad-intl, intr} state that $[[Int]]$ and $[[A -> B]]$ are disjoint types.
\Rref{ad-orl, ad-orl} are two symmetric rules for union types. Any type $[[C]]$ is disjoint
to union type $[[A \/ B]]$ if $[[C]]$ is disjoint to both $[[A]]$ and $[[B]]$. Next we show
soundness and completeness for disjointness.

\begin{lemma}[Soundness]
\label{lemma:union:sound}
$\forall ~ A ~ B, ~[[A * B]] ~ \rightarrow ~ [[A *s B]]$.
\end{lemma}

\begin{proof}
By induction on disjointness relation.
All cases are trivial to prove.
\end{proof}

\begin{lemma}[Completeness]
\label{lemma:union:complete}
$\forall ~ A ~ B, ~[[A *s B]] ~ \rightarrow ~ [[A * B]]$.
\end{lemma}

\begin{proof}
By induction on type A.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type Safety and Determinism
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Type Safety and Determinism}
\label{sec:union:safety}
Calculus discussed in this section is type safe and deterministic. In this section we discuss the
proofs of type safety and determinism for \cal. Type safety is usually considered as composition
of type preservation and progress lemma. Type preservation states that types are preserved during
reduction. Progress states well typed programs never get stuck. A well typed expression $[[e]]$ is 
either a value or it can take step to some $[[e']]$. Type of $[[e']]$ is preserved following the
type preservation property. Therefore, preservation and progress together ensure type safety.
We add one more choice in the conslusion of prorgress lemma to handle non-annotated lambda expressions 
($[[\x.e]]$).

\begin{lemma}[Type Preservation]
\label{lemma:union:preservation}
  If \ $[[G |- e dirflag A]]$ and $[[e --> e']]$ then: $[[G |- e' dirflag A]]$.
\end{lemma}

\begin{proof}
  By induction on typing relation and subsequent inverting reduction relation.
  \begin{itemize}
    \item Cases \rref{typ-int, typ-var, typ-sub, typ-abs} are trivial to prove.
    \item Case \rref{typ-ann} requires helping \cref{lemma:union:check-pexpr-ann}.
    \item Case \rref{typ-app} requires helping \cref{lemma:union:pexpr-check-sub}
          and substitution \cref{lemma:union:substitution} for beta reduction.
    \item Case \rref{typ-typeof} requires substitution \cref{lemma:union:substitution}.
  \end{itemize}
\end{proof}

\baber{ToDo: change name of helping lemmas.}

\begin{lemma}[check-pexpr-ann]
\label{lemma:union:check-pexpr-ann}
  If \ $[[G |- p:C <= A]]$ \ then \ $[[G |- p <= A]]$.
\end{lemma}

\begin{lemma}[pexpr-check-sub]
\label{lemma:union:pexpr-check-sub}
  If \ $[[G |- p <= A]]$ \ and \ $[[A <: B]]$ \ then \ $[[G |- p <= B]]$.
\end{lemma}

\begin{lemma}[Substitution]
\label{lemma:union:substitution}
  If \ $[[G, x:B , G1 |- e dirflag A]]$ \ and \ $[[G |- e' => B]]$
  then \ $[[G, G1 |- e [ x ~> e' ] dirflag A]]$
\end{lemma}

\begin{lemma}[Progress]
\label{lemma:union:progress}
If \ $[[ [] |- e dirflag A]]$ then:
 \begin{enumerate}
  \item either $[[e]]$ is a value.
  \item or $[[e]]$ can take a step to $[[e']]$.
  \item or $[[e]]$ = $[[\x.e]]$ and $[[dirflag]]$ = $[[<=]]$
  \end{enumerate}
\end{lemma}

\begin{proof}
By induction on typing relation.
  \begin{itemize}
    \item Cases \rref{typ-int, typ-var, typ-app, typ-sub, typ-abs} are trivial to prove.
    \item Case \rref{typ-anno} requires \cref{lemma:union:value-not-value}.
    \item Case \rref{typ-typeof} requires 
    \cref{lemma:union:check-pexpr-ann,lemma:union:check-or-typ,lemma:union:pexpr-inf-typ}.
  \end{itemize}
\end{proof}

\begin{lemma}[Value Decidability]
\label{lemma:union:value-not-value}
$\forall$ $[[e]]$, \ value \ $[[e]]$ \ $\vee$ \ $\neg$ value \ $[[e]]$.
\end{lemma}

\begin{lemma}[check-or-typ]
\label{lemma:union:check-or-typ}
If \ $[[A *s B]]$ \ and \ $[[G |- p <= A \/ B]]$ \ then:
  \begin{enumerate}
    \item either \ $[[G |- p <= A]]$
    \item or \ $[[G |- p <= B]]$
  \end{enumerate}
\end{lemma}

\begin{lemma}[pexpr-inf-typ]
\label{lemma:union:pexpr-inf-typ}
If \ $[[G |- p <= A]]$ \ then:
  \begin{enumerate}
  \item $\exists$ $[[B]]$, \ $[[B <: A]]$
  \item and \ $[[G |- p => B]]$
  \end{enumerate}
\end{lemma}

\begin{lemma}[Determinism]
\label{lemma:union:determinism}
  If \ $[[G |- e dirflag A]]$
  \begin{enumerate}
  \item and \ $[[e --> e1]]$
  \item and \ $[[e --> e2]]$ \\
  then: $[[e1]]$ = $[[e2]]$.
  \end{enumerate}
\end{lemma}

\begin{proof}
  By induction on first reduction relation and inverting second reduction relation subsequently.
  All cases are trivial to solve by simple inversions except:
  \begin{itemize}
    \item Case \rref{typ-typeof} requires \cref{lemma:union:check-both-disj-false}.
  \end{itemize}
\end{proof}

\begin{lemma}[check-both-disj-false]
\label{lemma:union:check-both-disj-false}
If \ $[[A *s B]]$ \ and \ $[[G |- p <= A]]$ \ and \ $[[G |- p <= B]]$ \ then \ False.
\end{lemma}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discussion on Disjointness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion on Disjointness}
\label{sec:union:discussion}
In this section we discuss limited power of our current disjoint specifications 
(\cref{def:union:disj}) and propose a robust and scalable definition for disjoint specifications.
\Cref{def:union:disj} works fine in calculus as of now. But it adds complexities as soon as we add
intersection types to make the system more expressive.