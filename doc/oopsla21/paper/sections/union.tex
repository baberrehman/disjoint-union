\section{The Union Calculus (\name)}
\label{sec:union}

\snow{Pls fix ``and without intersection types''. Besides don't use commands for
  text because it leads to incorrect capitalization. You can use ``emph'' instead
  of capitalizing.} \baber{I guess Bruno already fixed that.}
This section introduces the union calculus \name. The distinctive feature
of the \name calculus is a type-based switch expression with disjoint
cases, which can be used to eliminate values with union types.
%Such type-based
%switch expression is inspired by a similar construct in the Ceylon programming
%language.
We adapt the notion of disjointness from previous work on
\emph{disjoint intersection types}~\cite{} to \name, and show that \name is type
sound and deterministic.

%%%%%%%%%%%%%%%%%%%%%
%% Syntax
%%%%%%%%%%%%%%%%%%%%%

\subsection{Syntax}\label{sec:union:syntax}
\snow{The latex definition of typeof in ott needs to be revised. Now ``typeof''
  and ``as'' are in mathmode, I think they look better in text mode.
  Same applies to ``ord''.
  And why there are two latex definition for typeof in ott? The other one
  has variable ``x'' in it. I think we do need such a variable.
  Pls fix the notation.}
\bruno{Lets change ``typeof e as'' to ``switch e'', and Snow is right:
you need the variables, brackets eytc. in the syntax.}
\baber{Done, updated typeof to $[[switch e A e1 B e2]]$.}
\Cref{fig:union:syntax} shows the syntax for \cal. Metavariables
$[[A]]$, $[[B]]$ and $[[C]]$ range over types.  Types include top ($[[Top]]$),
bottom ($[[Bot]]$), function ($[[A -> B]]$) and union ($[[A \/ B]]$)
types. Metavariable $[[e]]$ ranges over program
expressions. Expressions include variables ($[[x]]$), natural numbers
($[[i]]$), type annotations ($[[e:A]]$), lambda abstractions
($[[\x.e]]$), applications ($[[e1 e2]]$) and a novel switch ($[[switch
    e A e1 B e2]]$) expression. \emph{Switch} expression is a case
expression and evaluates a specific branch by matching the
type.
%Details of \typeof expression will further be discussed in typing
%and operational semantics sections.

\paragraph{Values and pre-values.} In \name all the values have
a type annotation. The type annotation represents the dynamic type
that the value has at runtime, and
it is helpful for the type-directed dynamic semantics.
We divide the representation for values into two parts: pre-values and
values.
Metavariable $[[p]]$ ranges over pre-values. Pre-values
consist of natural numbers $[[i]]$
and annotated lambda expressions $[[\x.e : A -> B]]$. Values are
annotated pre-values. Metavariable $[[v]]$ ranges over
values. It is important to note that $[[i]]$ is not a value in this
calculus, instead $[[i:Int]]$ or $[[i:Top]]$ are values.
In addition, lambdas have two annotations. That is $[[\x.e : A -> B : C]]$ is a value.
As already mentioned, $C$ is the dynamic type of the value
at runtime, whereas $[[A -> B]]$ is the original \emph{static type} of the lambda.
For readers familiar with calculi with gradual types~\cite{}, the two annotations
can be also be understood as the \emph{source type} and \emph{target type}
of an upcast: i.e. if the value is well-typed we have that $[[A -> B]] <: [[C]]$.

A context ($[[G]]$) can
either be empty or contains type bindings of variables and associated
types. Finally, a typing mode ($[[dirflag]]$) can either be check ($[[<=]]$)
or inference ($[[=>]]$).

\begin{figure}[t]
  \begin{small}
    \centering
    \begin{tabular}{lrcl} \toprule
      Types & $[[A]], [[B]]$, $[[C]]$ & $\Coloneqq$ & $ [[Top]] \mid [[Bot]] \mid [[Int]] \mid [[A -> B]] \mid [[A \/ B]] $ \\
      Expr & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[e:A]] \mid [[\x.e]] \mid [[e1 e2]] \mid [[switch e A e1 B e2]]$\\
      PValue & $[[p]]$ & $\Coloneqq$ & $[[i]] \mid [[\x.e : A -> B]] $\\
      Value & $[[v]]$ & $\Coloneqq$ & $[[p:A]]$\\
      Context & $[[G]]$ & $\Coloneqq$ & $ \cdot \mid [[G , x : A]]$ \\
      Mode & $[[dirflag]]$ & $\Coloneqq$ & $[[<=]] \ \mid \ [[=>]]$ \\
      \bottomrule
    \end{tabular}
  \end{small}
  \begin{small}
    \centering
    \drules[s]{$ [[A <: B ]] $}{Algorithmic Subtyping}{top, bot, int, arrow, ora, orb, orc}
  \end{small}
  \ningning{Why we say the subtyping definition is algorithmic but it is not
    even syntax-directed?}

  \caption{Syntax and Algorithmic Subtyping for \cal. \snow{We need to add C as
      a metavariable for types here because it is used later.} \baber{Done.} }
  \label{fig:union:syntax}
\end{figure}
\bruno{Add the syntax for the bi-directional modes in the Figure.} \baber{Done.}

%%%%%%%%%%%%%%%%%%%%%
%% Subtyping
%%%%%%%%%%%%%%%%%%%%%
\subsection{Subtyping}
\label{sec:union:sub}
Algorithmic subtyping rules for \cal are shown in
\Cref{fig:union:syntax}. The subtyping rules are standard for a system
with union types.  \Rref{s-top} states that all types are subtypes of
the $[[Top]]$ type. \Rref{s-bot} states that $[[Bot]]$ type is subtype of
all types. \Rref{s-int, s-arrow} are standard rules for integers and
functions respectively.  Functions are contravariant in input types
and covariant in output types. \Rref{s-ora, s-orb, s-orc} are standard
subtyping rules for union types. The union type of two types $A1$ and $A2$
is a subtype of another type $A$ if both $A1$ and $A2$ are subtypes of
$A$, as stated in \rref{s-ora}. \Rref{s-orb, s-orc} states that if a
type is subtype of one of the components of a union type, then it is subtype of whole
union type.  The subtyping relation for \cal is reflexive and transitive.
\begin{lemma}[Subtyping Reflexivity]
  $[[A <: A]]$.
\label{lemma:union:refl}
\end{lemma}
\begin{comment}
\begin{proof}
  By induction on type A. All cases are trivial to prove.
\end{proof}
\end{comment}
\begin{lemma}[Subtyping Transitivity]
  If \ $[[A <: B]]$ \ and \ $[[B <: C]]$ \ then \ $[[A <: C]]$.
  \label{lemma:union:trans}
\end{lemma}
\begin{comment}
\begin{proof}
  By induction on type B.
  \begin{itemize}
    \item Cases $[[Top]]$, $[[Bot]]$ and $[[Int]]$ are trivial to prove.
    \item Case $[[A -> B]]$ requires double induction on type $[[C]]$
          and $[[A]]$.
    \item Case $[[A \/ B]]$ requires \Cref{lemma:union:sub-or}
  \end{itemize}
\end{proof}\bruno{If space is a concern we can probably drop the lemma statements
for reflexivity and transitivity as these are quite standard.}

\begin{lemma}[Subtyping Union Inversion]
\label{lemma:union:sub-or}
  If \ $[[A \/ B <: C]]$ then:
  \begin{enumerate}
    \item $[[A <: C]]$ and
    \item $[[B <: C]]$
  \end{enumerate}
\end{lemma}
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%
%% Disjointness
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disjointness}
\label{sec:union:disj}
\baber{Mainly focused on technical details in this section. Story and benefits of disjointness may be discussed in another section.}
In this section we discuss in detail the notion of disjointness for
union types and case expression for \cal. In essence disjointness for \cal is
the dual to disjointness for $\lambda_i$~\cite{oliveira2016disjoint}, which is
a calculus with disjoint intersection types. In $\lambda_i$, two
types in are disjoint if they do not share any common
\emph{supertype} which is not \emph{top-like}. In contrast, in
\cal, two types in are disjoint if they do not share any common \emph{subtype} which
is not \emph{bottom-like}.
\bruno{In the overview section we need to talk about more about this and
explain that common subtypes are important for the switch expression.}
We emphasize the significance of
\emph{supertypes} and \emph{subtypes} in $\lambda_i$ and \cal
respectively.

\paragraph{Bottom-Like Types}
\emph{Bottom-like} types are types that are isomorphic (i.e.
both supertypes and subtypes) of the type $\bot$. In \name there
are infinitely many such types, including, for example $\bot \lor \bot$,
$\bot \lor \bot \lor \bot$, as well as $\bot$ itself. Bottom-like types
are important because they allow us to define disjointness.
%are integral part of disjoitness in \cal like
%\emph{top-like} in $\lambda_i$ \cite{oliveira2016disjoint}. Therefore,
%it is important to understand the notion of \emph{bottom-like} types
%before diving into the details of disjointness.
Intuitively, a
\emph{bottom-like} type is a type which behaves like $[[Bot]]$ type.
An inductive definition that captures all the bottom-like types
is shown at the top of \Cref{fig:union:disj-typ}.
Type $[[Bot]]$ is obviously a \emph{bottom-like} type
(\rref{bl-bot}), and a union type of two \emph{bottom-like} types is also
a \emph{bottom-like} type (\rref{bl-or}).  It is trivial to conclude
that a union type is \emph{bottom-like} only if all the primitive
types in union are $[[Bot]]$. The correctness of our definition for
bottom-like types is ensured by the following properties:

\begin{lemma}[Bottom-Like Soundness]
  If \ $[[botlike A]]$ \ then \ $[[A <: B]]$.
\label{lemma:union:bl-soundness}
\end{lemma}

\begin{comment}
\begin{proof}
  By induction on bottom-like relation.
  \begin{itemize}
    \item All cases are trivial to prove.
  \end{itemize}
\end{proof}
\end{comment}

\begin{lemma}[Bottom-Like Completeness]
  If \ $[[A <: B]]$ \ then \ $[[botlike A]]$.
\label{lemma:union:bl-completeness}
\end{lemma}

\begin{comment}
\begin{proof}
  By induction on type $[[A]]$.
  \begin{itemize}
    \item Cases $[[Top]]$, $[[Bot]]$, $[[Int]]$ and $[[A -> B]]$ are trivial to prove.
    \item Case $[[A \/ B]]$ requires \Cref{lemma:union:sub-or}.
  \end{itemize}
\end{proof}
\end{comment}

\paragraph{Declarative Disjointness}
The formal (declarative) definition for disjointness in \name is:
%Recall that two types in \cal are disjoint if they do not share any common subtype which is not
%\emph{bottom-like}. The formal definition of disjoint specifications for this calculus is:

\begin{definition}
  A $*_s$ B $\Coloneqq$ $\forall$ C, $[[C <: A]]$ $\wedge$ $[[C <: B]]$ $\rightarrow$ $[[botlike C]]$
\label{def:union:disj}
\end{definition}

\noindent That is, two types are disjoint if all their common subtypes are bottom-like.
\begin{comment}
With this definition we have that different primitive types are disjoint. For example
$[[Int]] * [[Bool]]$ since the only common subtypes of $[[Int]]$ and $[[Bool]]$
are bottom-like. A more interesting case is the disjointness of two function types.
It turns out that function types are never disjoint, since we can always find
a common subtype for any two function types. For example, if we have $[[Int -> Bool]]$
and $[[String -> Char]]$ then a common subtype that is not bottom-like is
$[[Top -> Bot]]$. Therefore, $[[Int -> Bool]]$ and $[[String -> Char]]$ are not
disjoint.

\noindent Reader may think at this point that $[[Bot]]$ type can simply be used in \Cref{def:union:disj}
instead of $[[botlike C]]$ in the conclusion. Answer to this question is
union type with $[[Bot]]$ as all primitive types is also a least subtype in \cal.
$[[botlike C]]$ also handles this case.
\end{comment}
We illustrate this definition with a few simple examples:

\begin{enumerate}
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Int -> Bool]]:}$ \\
        $[[Int]]$ and $[[Int -> Bool]]$ are disjoint types. All common subtypes of $[[Int]]$ and $[[A -> B]]$ are bottom-like types, 
        including $[[Bot]]$ and union of $[[Bot]]$ types. 
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Bot]]:}$ \\
    $[[Int]]$ and $[[Bot]]$ are disjoint types, since again all common subtypes are bottom-like. In general, the type $[[Bot]]$ (or any other bottom-like type)
    is disjoint to any other type.
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Int]]:}$ \\
        $[[Int]]$ and $[[Int]]$ are not disjoint types because they share a common subtype $[[Int]]$ which
        is not \emph{bottom-like}.
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Top]]:}$ \\
        $[[Int]]$ and $[[Top]]$ are not disjoint types because they share a common
    subtype $[[Int]]$ which is not \emph{bottom-like}. In general no type
    is disjoint to $[[Top]]$. 
  \item $\boldsymbol{A = [[Int -> Bool]], \ B = \ [[String -> Char]]:}$
    The types $[[Int -> Bool]]$ and $[[String -> Char]]$ are not disjoint,
    since they share we can find non-bottom-like types that are subtypes
    of both types. For instance $[[Top -> Bot]]$ is a subtype of both types.
    More generally, any two function types can never be disjoint: it is always
    possible to find a common subtype, which is not bottom-like.
    \\
\end{enumerate}

\begin{comment}
\begin{figure}[t]
  \begin{small}
    \centering
    \drules[ad]{$[[A * B]]$}{Algorithmic Disjointness}{btmr, btml, intl, intr, orl, orr}
  \end{small}
  \caption{Algorithmic Disjointness for \cal.}
  \label{fig:union:ad}
\end{figure}
\end{comment}

\paragraph{Algorithmic Disjointness}
The middle part of \Cref{fig:union:disj-typ} shows an algorithmic
version of disjointness.  \Rref{ad-btmr, ad-btml} state that the $[[Bot]]$
type is disjoint to all types.  \Rref{ad-intl, intr} state that
$[[Int]]$ and $[[A -> B]]$ are disjoint types.  Algorithmic
disjointness can further be scaled to more primitive disjoint types
such as $Bool$ and $String$ by adding more rules similar to
\rref{ad-intl, intr} for additional primitive types.  \Rref{ad-orl,
  ad-orr} are two symmetric rules for union types. Any type $[[C]]$ is
disjoint to an union type $[[A \/ B]]$ if $[[C]]$ is disjoint to both
$[[A]]$ and $[[B]]$.  Algorithmic disjointness is sound and complete
with respect to \Cref{def:union:disj}, and disjointness is a symmetric
relation. The following lemmas summarize key properties of disjointness.

\begin{lemma}[Disjointness Soundness]
  If \ $[[A * B]]$ \ then \ $[[A *s B]]$.
\label{lemma:union:disj-sound}
\end{lemma}

\begin{comment}
\begin{proof}
  By induction on algorithmic disjointness relation.
  \begin{itemize}
    \item Cases \rref{ad-btmr, ad-btml, ad-orl, ad-orr} require induction on hypothesis
          and \Cref{lemma:union:sub-or}.
    \item Cases \rref{ad-intl, ad-intr} require induction on type and \Cref{lemma:union:sub-or}.
  \end{itemize}
\end{proof}
\end{comment}

\begin{lemma}[Disjointness Completeness]
  If \ $[[A *s B]]$ \ then \ $[[A * B]]$.
\label{lemma:union:disj-complete}
\end{lemma}

\begin{comment}
\begin{proof}
  By induction on type A.
  \begin{itemize}
    \item Case $[[Top]]$ requires \Cref{lemma:union:bl-disj}.
    \item Case $[[Bot]]$ is trivial to prove.
    \item Case $[[Int]]$ requires induction on type B and
          \Cref{lemma:union:bl-disj,lemma:union:disj-sym}.
    \item Case $[[A -> B]]$ requires induction on type B and \Cref{lemma:union:disj-sym}.
    \item Case $[[A \/ B]]$ follows directly from inductive hypothesis.
  \end{itemize}
\end{proof}

\begin{lemma}[Bottom-like Types Disjoint]
\label{lemma:union:bl-disj}
  If \ $[[botlike A]]$ \ then: \ $[[A * B]]$.
\end{lemma}

\begin{lemma}[Disjointness Symmetry]
\label{lemma:union:disj-sym}
  If \ $[[A * B]]$ \ then: \ $[[B * A]]$.
\end{lemma}
\end{comment}

\begin{lemma}[Bottom-Like Disjoint]
  If \ $[[botlike A]]$ \ then \ $[[A * B]]$.
\label{lemma:union:bl-disjoint}
\end{lemma}

\begin{lemma}[Disjointness Symmetry]
  If \ $[[A * B]]$ \ then \ $[[B * A]]$.
\label{lemma:union:disj-sym}
\end{lemma}

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[bl]{$[[botlike A]]$}{Bottom-Like Types}{bot, or}
  \end{small}
  \begin{small}
    \centering
    \drules[ad]{$[[A * B]]$}{Algorithmic Disjointness}{btmr, btml, intl, intr, orl, orr}
  \end{small}
  \begin{small}
    \centering
    \drules[typ]{$ [[G |- e dirflag A]] $}{Bidirectional Typing}{int, var, ann, app, sub, abs, switch}
  \end{small}
  \caption{Bottom-Like types, Algorithmic Disjointness and Typing for \cal.}
  \label{fig:union:disj-typ}
\end{figure}
\bruno{The syntax of typeof needs to be fixed, otherwise the variable ``x'' in the
typing rule appears from nowhere!}
\baber{Done, updated typeof to $[[switch e A e1 B e2]]$.}


%%%%%%%%%%%%%%%%%%%%%
%% Typing
%%%%%%%%%%%%%%%%%%%%%
\subsection{Typing}
\label{sec:union:typ}
The typing rules are shown at the bottom of \Cref{fig:union:disj-typ}.
We adopt bidirectional type-checking~\cite{} in our calculus.  There
are two typing modes in bidirectional typing: inference mode
($[[=>]]$) and checking mode ($[[<=]]$). In inference mode, the type of
an expression $[[e]]$ is inferred or calculated based upon certain
information available in the given context $[[G]]$.  While in checking
mode, an expression $[[e]]$ is checked against a given type $[[A]]$.
Typing rules are mostly standard.  An integer
expression $[[i]]$ infers type $[[Int]]$ as stated in \rref{typ-int}.
\Rref{typ-var} states that a variable $[[x]]$ infers type $[[A]]$ if
$[[x]]$ has type $[[A]]$ in the given context. \Rref{typ-ann} states
if an expression $[[e]]$ checks against type $[[A]]$, then the
annotated expression $[[e:A]]$ infers type $[[A]]$.
\Rref{typ-app} type checks a function application and it is the
elimination rule for functions.
\begin{comment}
Expression $[[e1]]$ has to
be a function expression and expression $[[e2]]$ has to check against
input type of $[[e1]]$.  An important point to notice in
\rref{typ-app} is $[[e1]]$ infers type $[[A -> B]]$. This may look
weird at the very first glance because lamda expressions ($[[\x.e]]$)
are not annotated in program expressions $[[e]]$ and it seems not
possible for lambda expression to infer its type.  To answer this
question, we emphasize the use of partial expressions $[[p]]$ and
values $[[v]]$.  Lambda expression is annotated in $[[p]]$ and so in
$[[v]]$ because values are defined as annotated partial expressions.
\end{comment}
\Rref{typ-sub} is the subsumption rule. It states that an expression
$[[e]]$ can be checked against any supertype of its inferred type.
\Rref{typ-abs} is the standard introduction rule for lambda
expressions. To check a lambda expression $[[\x.e]]$ against type $[[A
    -> B]]$, it is sufficient to check lambda body $[[e]]$ against the
output type $[[B]]$ in an extended context with parameter $[[x]]$ of
input type $[[A]]$.

The most interesting and novel typing rule is for
\emph{switch} expressions. Four conditions are necessary for typing
\emph{switch} expressions.
%The remaining conditions are standard for a calculus with
%union types and case expression and have been studied in various
%calculi (\baber{reference to calculi}).
The first condition ($[[G |-
    e <= A \/ B]]$) ensures that case expression $[[e]]$ is well-typed
and checks against type $[[A \/ B]]$.  The next two conditions ensure that
branches of case expression are well-typed and check against some type
$[[C]]$. An important point in these two conditions is that variable
$[[x]]$ is of type $[[A]]$ in first branch and of type $[[B]]$ in
second branch in the extended context.  From the last condition
$[[A *s B]]$, we guarantee that $[[A]]$ and $[[B]]$ are disjoint
types. Overlapping types for the 
branches of case expressions can lead to non-deterministic 
results, and are therefore forbidden.
Since all the branches check against $[[C]]$, the whole
\emph{switch} expression checks against $[[C]]$.

\begin{comment}
\begin{figure}[t]
  \begin{small}
    \centering
    \drules[typ]{$ [[G |- e dirflag A]] $}{Bidirectional Typing}{int, var, ann, app, sub, abs, typeof}
  \end{small}
  \caption{Typing for \cal.}
  \label{fig:union:typ}
\end{figure}
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%
%% Operations Semantics
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Operational Semantics}
\label{sec:union:os}
Dynamics of \cal are defined by small-step operational semantics.
\Cref{fig:union:os} shows operational semantics of \cal. Before going
into the details of operational semantics, it is important to recall
partial expressions and values. An integer expression $[[i]]$ or a
lambda expression $[[\x.e]]$ are not values unless annotated. Lambda
expression has to be dually annotated to fulfill the criteria to be a
value. Operational semantics follow call-by-value evaluation strategy.
We empahsize the use of another interesting and novel technique which
is type directed operational semantics \baber{reference here}. Types
are preserved by type annotations during substitution in
beta-reduction and \emph{switch} cases.

\Rref{step-int} annotates integer expressions and makes them values. \Rref{step-appl} reduces left expression
of an application unless it becomes a value. \Rref{step-appr} works only if left expression of an
application is already reduced to value. \Rref{step-appr} then reduces right expression of
application to a value.
\Rref{step-beta} is the beta-reduction. It applies dually annotated lambda expression
$[[\x.e : A1 -> B1 : A2 -> B2]]$ to input value $[[p:C]]$. Substitution replaces free occurances of variable
$[[x]]$ with value $[[p:A1]]$. Note that annotation of partial value $[[p]]$ has changed to $[[A1]]$ from
$[[C]]$ during substitution.
This is to keep the most specific type in annotation. Substituted expression is also
annotated with both of the output types from annotated lambda expression. \baber{More details.}

\Rref{step-absbeta} deals with the simple lambda expressions of the form $[[\x.e]]$ as input to a function.
It follows same as \rref{step-beta} except that both of the input types are kept with $[[\x.e]]$ during
substitution i.e $[[\x.e:A2:A1]]$. \Rref{step-ann} reduces an annotated expression only if it is not a value
and $[[e]]$ reduces to some $[[e']]$. \Rref{step-rmann} drops inner annotation. \Rref{step-lamann} adds one
more type annotation with lambda expressions having single type annotation to make them values.
\Rref{step-switch, step-switchl, step-switchr} deal with the reduction of \emph{switch} expressions.

\Rref{step-switch} reduces the case expression $[[e]]$ unless it becomes a value of the form $[[p:D]]$.
\Rref{step-switchl} evaluates left branch of the \emph{switch} expression if type of $[[e]]$ is subtype
of type of left branch.
\Rref{step-switchr} evaluates right branch of the \emph{switch} expression if type of $[[e]]$ is subtype
of type of right branch.
Subtyping condition in \rref{step-switchl, step-switchr} is interesting and important to consider.
It gives a freedom of various subtypes of $[[A]]$ and $[[B]]$ for corresponding branch instead of only
type $[[A]]$ and type $[[B]]$.
It is important to note that types of left and right branches of \emph{switch} expression cannot overlap
because of disjoitness contraint in typing. Programs with overlapping types in branches of \emph{switch}
expression will not type check in \cal.
A natural property of \cal is if type $[[A]]$ and type $[[B]]$ are two
disjoint types, then subtypes of $[[A]]$ are also disjoint to subtypes of $[[B]]$.

\paragraph{FindType Relation} FindType relation calculates the type of partial expressions
and is shown in lower part of \Cref{fig:union:os}. It takes $[[p]]$ as input and returns its type.
Partial expressions in \cal are $[[i]]$ and $[[\x.e: A -> B]]$.
FindType returns $[[Int]]$ when $[[p]]$ is an integer $[[i]]$ (\rref{findtype-int}). On the other hand,
FindType returns $[[A -> B]]$ against the partial expression $[[\x.e : A->B]]$ (\rref{findtype-arrow}).

\begin{figure}[t]
  \begin{small}
    \centering
    \drules[step]{$[[e --> e']]$}{Operational Semantics}{int, appl, appr, beta, absbeta, ann, rmann, lamann, switch, switchl, switchr}
  \end{small}
  \begin{small}
    \centering
    \drules[findtype]{$[[findtype p A]]$}{FindType}{int, arrow}
  \end{small}
  \caption{Operational semantics for \cal and FindType.}
  \label{fig:union:os}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type Safety and Determinism
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Type Safety and Determinism}
\label{sec:union:safety}
\cal is type safe and deterministic. In this section we discuss the
proofs of type safety and determinism for \cal. Type safety is usually considered as composition
of type preservation and progress lemma. Type preservation (\Cref{lemma:union:preservation})
states that types are preserved during
reduction. Progress (\Cref{lemma:union:progress}) states well typed programs never get stuck.
A well typed expression $[[e]]$ is
either a value or it can take step to some $[[e']]$. Type of $[[e']]$ is preserved following the
type preservation property. Therefore, preservation and progress together ensure type safety.
We add one more choice in the conslusion of prorgress lemma to handle non-annotated lambda expressions
($[[\x.e]]$).
Determinism (\Cref{lemma:union:determinism}) is also a critical property for a calculus.
Non-deterministic calculi lead to incoherent programs.
Determinism ensures that a program will always produce the same unique result.

\begin{lemma}[Type Preservation]
\label{lemma:union:preservation}
  If \ $[[G |- e dirflag A]]$ and $[[e --> e']]$ then $[[G |- e' dirflag A]]$.
\end{lemma}

\begin{comment}
\begin{proof}
  By induction on typing relation and subsequent inverting reduction relation.
  \begin{itemize}
    \item Cases \rref{typ-int, typ-var, typ-sub, typ-abs} are trivial to prove.
    \item Case \rref{typ-ann} requires helping \cref{lemma:union:check-pexpr-ann}.
    \item Case \rref{typ-app} requires helping \cref{lemma:union:pexpr-check-sub}
          and substitution \cref{lemma:union:substitution} for beta reduction.
    \item Case \rref{typ-typeof} requires substitution \cref{lemma:union:substitution}.
  \end{itemize}
\end{proof}

\baber{ToDo: change name of helping lemmas.}

\begin{lemma}[check-pexpr-ann]
\label{lemma:union:check-pexpr-ann}
  If \ $[[G |- p:C <= A]]$ \ then \ $[[G |- p <= A]]$.
\end{lemma}

\begin{lemma}[pexpr-check-sub]
\label{lemma:union:pexpr-check-sub}
  If \ $[[G |- p <= A]]$ \ and \ $[[A <: B]]$ \ then \ $[[G |- p <= B]]$.
\end{lemma}
\end{comment}

\begin{lemma}[Substitution]
\label{lemma:union:substitution}
  If \ $[[G, x:B , G1 |- e dirflag A]]$ \ and \ $[[G |- e' => B]]$
  then \ $[[G, G1 |- e [ x ~> e' ] dirflag A]]$
\end{lemma}

\begin{lemma}[Progress]
\label{lemma:union:progress}
If \ $[[ [] |- e dirflag A]]$ then
 \begin{enumerate}
  \item either $[[e]]$ is a value.
  \item or $[[e]]$ can take a step to $[[e']]$.
  \item or $[[e]]$ = $[[\x.e]]$ and $[[dirflag]]$ = $[[<=]]$
  \end{enumerate}
\end{lemma}

\begin{comment}
\begin{proof}
By induction on typing relation.
  \begin{itemize}
    \item Cases \rref{typ-int, typ-var, typ-app, typ-sub, typ-abs} are trivial to prove.
    \item Case \rref{typ-anno} requires \cref{lemma:union:value-not-value}.
    \item Case \rref{typ-typeof} requires
    \cref{lemma:union:check-pexpr-ann,lemma:union:check-or-typ,lemma:union:pexpr-inf-typ}.
  \end{itemize}
\end{proof}

\begin{lemma}[Value Decidability]
\label{lemma:union:value-not-value}
$\forall$ $[[e]]$, \ value \ $[[e]]$ \ $\vee$ \ $\neg$ value \ $[[e]]$.
\end{lemma}

\begin{lemma}[check-or-typ]
\label{lemma:union:check-or-typ}
If \ $[[A *s B]]$ \ and \ $[[G |- p <= A \/ B]]$ \ then:
  \begin{enumerate}
    \item either \ $[[G |- p <= A]]$
    \item or \ $[[G |- p <= B]]$
  \end{enumerate}
\end{lemma}

\begin{lemma}[pexpr-inf-typ]
\label{lemma:union:pexpr-inf-typ}
If \ $[[G |- p <= A]]$ \ then:
  \begin{enumerate}
  \item $\exists$ $[[B]]$, \ $[[B <: A]]$
  \item and \ $[[G |- p => B]]$
  \end{enumerate}
\end{lemma}
\end{comment}

\begin{lemma}[Determinism]
\label{lemma:union:determinism}
  If \ $[[G |- e dirflag A]]$
  \begin{enumerate}
  \item and \ $[[e --> e1]]$
  \item and \ $[[e --> e2]]$ \\
  then $[[e1]]$ = $[[e2]]$.
  \end{enumerate}
\end{lemma}

\begin{comment}
\begin{proof}
  By induction on first reduction relation and inverting second reduction relation subsequently.
  All cases are trivial to solve by simple inversions except:
  \begin{itemize}
    \item Case \rref{typ-typeof} requires \cref{lemma:union:check-both-disj-false}.
  \end{itemize}
\end{proof}

\begin{lemma}[check-both-disj-false]
\label{lemma:union:check-both-disj-false}
If \ $[[A *s B]]$ \ and \ $[[G |- p <= A]]$ \ and \ $[[G |- p <= B]]$ \ then \ False.
\end{lemma}
\end{comment}

\baber{Again, should we show the property that a term cannot be checked against two disjoint types?}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discussion on Disjointness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion on Disjointness}
\label{sec:union:discussion}
Interaction of intersection and union types is a well-known problem in programming languages.
In this section we discuss limited expressive power of our current disjoint specifications
(\cref{def:union:disj}) and propose a robust and scalable definition for disjointness.
\Cref{def:union:disj} works fine in simple calculus as of now. But it adds complexities as soon as we add
intersection types to make the system more expressive.

\paragraph{Updated Disjointness}
An updated and robust declerative disjointness is shown in \Cref{fig:union:ord} as \Cref{def:union:disj1}.
It is important to establish the fact that \Cref{def:union:disj1} works as expected.
We prove equivalence of \Cref{def:union:disj} and \Cref{def:union:disj1} to establish this fact.
Examples illustrated in \Cref{sec:union:disj} also work fine with the updated disjointness definition.
\Cref{def:union:disj1} will be discussed in detail in \Cref{sec:inter} along with corresponding
algorithmic version.

\begin{lemma}[Disjointness Equivalence]
A $*_{s}$ B $\longleftrightarrow$ A $*_{s1}$ B.
\end{lemma}

\begin{figure}
    \centering
    \drules[ord]{$[[ordinary A]]$}{Ordinary Types}{top, int, arrow}
  \medskip
  \begin{definition}
    \centering
    A $*_{s1}$ B $\Coloneqq$ $\forall$ C, $[[ordinary C]]$ $\rightarrow$ $\neg$ ($[[C <: A]]$ $\wedge$ $[[C <: B]]$)
    \label{def:union:disj1}
  \end{definition}
  \caption{Updated disjointness and ordinary types for \cal.
    \snow{I think there is no need to make figure small
    unless we are going to exceed the page limit.} \baber{Sure, I fixed that.}}
  \label{fig:union:ord}
\end{figure}
