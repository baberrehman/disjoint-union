\section{\cal with Intersection Types: The Challenge of Disjointness}
\label{sec:inter}

In this section we add intersection types to \cal.
%The study of an
%extension of \cal with intersection types is motivated by the fact
%that most languages support both union and intersection types.
%Therefore it is important to understand whether intersection types
%can be easily added or whether there are some challenges.
The addition of intersection types poses a challenge,
since the notion of disjointness that is inspired from disjoint intersection
types no longer works. However, the alternative definition presented in
Section~\ref{sec:union:discussion} comes to the rescue. Furthermore, we show how to obtain
an algorithmic formulation of disjointness based on a novel notion
called \emph{lowest ordinary subtypes}. All the properties, including
type soundness and determinism are preserved in the extension of \cal
with intersection types.

%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax and Semantics
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Syntax, Subtyping, Typing and Semantics}
\label{sec:inter:system}
The syntax, subtyping, typing and dynamic semantics for this section mostly follows
from \Cref{sec:union}.  The additional types and rules are shown in
\Cref{fig:inter:system}.
%This system can trivially be extended with
%more primitive types. We also have $Bool$ and $String$ types in our
%Coq formalization.
The most significant difference and novelty in this section
is because of the addition of intersection types $[[A
    /\ B]]$. Expressions $[[e]]$, partial expressions $[[p]]$, values
$[[v]]$, and context $[[G]]$ stay same as in \Cref{sec:union}. Typing
and operational semantics are also the same as in \Cref{sec:union}.
\cal with intersection types is type-safe and deterministic.
\baber{Need to restate type safety lemmas and discuss challenges
  involved.}
\bruno{If there are challenges then we can indeed expand the text and discuss the challenges
perhaps.}
Type safety is shown by type preservation (\Cref{lemma:inter:preservation}) and
progress (\Cref{lemma:inter:progress}). \baber{Should we restate determinism lemma too?}

\begin{lemma}[Type Preservation]
\label{lemma:inter:preservation}
  If \ $[[G |- e dirflag A]]$ and $[[e --> e']]$ then $[[G |- e' dirflag A]]$.
\end{lemma}

\begin{lemma}[Substitution]
\label{lemma:inter:substitution}
  If \ $[[G, x:B , G1 |- e dirflag A]]$ \ and \ $[[G |- e' => B]]$
  then \ $[[G, G1 |- e [ x ~> e' ] dirflag A]]$
\end{lemma}

\begin{lemma}[Progress]
\label{lemma:inter:progress}
If \ $[[ [] |- e dirflag A]]$ then
 \begin{enumerate}
  \item either $[[e]]$ is a value.
  \item or $[[e]]$ can take a step to $[[e']]$.
  \item or $[[e]]$ = $[[\x.e]]$ and $[[dirflag]]$ = $[[<=]]$
  \end{enumerate}
\end{lemma}

\paragraph{Subtyping}
The new rules for subtyping are shown in upper middle part of
\Cref{fig:inter:system}.  \Rref{s-anda, s-andb, s-andc} are for newly
added intersection types. \Rref{s-anda} states that a type $[[A]]$ is
subtype of intersection of two types $[[A1]]$ and $[[A2]]$ only if
$[[A]]$ is subtype of both $[[A1]]$ and $[[A2]]$. \Rref{s-andb,
  s-andc} state that an intersection type $[[A1 /\ A2]]$ is a subtype
of some type $[[A]]$ if either of its component types ($[[A1]]$ or
$[[A2]]$) is subtype of $[[A]]$. The subtyping relation is reflexive
and transitive.
\bruno{If there is space in the end we can state the lemmas.} \baber{Sure.}

\begin{figure}[t]
  \begin{small}
    \centering
    \begin{tabular}{lrcl} \toprule
      Types & $[[A]], [[B]]$ & $\Coloneqq$ & $ ... \mid [[A /\ B]] $ \\
      \bottomrule
    \end{tabular}
  \end{small}
  \medskip
    \begin{small}
    \centering
    \drules[s]{$ [[A <: B ]] $}{Additional Subtyping Rules}{anda, andb, andc}
  \end{small}
  \medskip
    \begin{small}
    \centering
    \drules[ord]{$[[ordinary A]]$}{Ordinary Types}{int, arrow}
  \end{small}
  \medskip
  %\begin{small}
    \centering
    \begin{tabular}{llcl}
      \toprule
      Lowest Ordinary Subtypes (LOS) $[[findsubtypes A]]$ &  & & \\
     & $[[findsubtypes Top]]$ & = & \{$ [[Int]], [[Top -> Bot]]$\}  \\
     & $[[findsubtypes Bot]]$ & = & \{\}  \\
     & $[[findsubtypes Int]]$ & = & \{$ [[Int]] $\}  \\
     & $[[findsubtypes A -> B]]$ & = & \{$ [[Top -> Bot]] $\}  \\
     & $[[findsubtypes A \/ B]]$ & = & $ [[findsubtypes A]] \cup [[findsubtypes B]] $\\
     & $[[findsubtypes A /\ B]]$ & = & $ [[findsubtypes A]] \cap [[findsubtypes B]] $\\
      \bottomrule
    \end{tabular}
  %\end{small}
  \caption{Additional Types, Subtyping, Ordinary Types and Lowest Ordinary Subtypes function for \cal with Intersection Types.}
  \label{fig:inter:system}
\end{figure}

\paragraph{Ordinary Types to the Rescue}
%Declarative disjointness is now defined in terms of ordinary types
%instead of \emph{bottom-like} types.
The lower middle part of
\Cref{fig:inter:system} shows ordinary types~\cite{}.
Ordinary types are essentially primitive types. In \cal they
are essentially integers and functions. 
%$[[Top]]$, $[[Int]]$ and $[[A -> B]]$ types are considered as ordinary
%types in \cal with intersection types.

%%%%%%%%%%%%%%%%%%%%%%%
%% Disjointness
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Disjointness Specification}
\label{sec:inter:disj}
Disjointness is the most interesting aspect of the extension of \cal with
intersection types. Unfortunatelly, \Cref{def:union:disj} does not work with intersection
types. We first explain why \Cref{def:union:disj} does not work, and then
we show how to introduce disjointness in the presence of intersection types. 

%We employ updated disjointness for \cal with intersection types as
%discussed in \Cref{sec:union:discussion} and discuss the updated
%disjointness in detail in this section.

\paragraph{Bottom-like Types, Intersection Types and Disjointness}
\bruno{Explain here why the disjointness spec in S3 fails.
  Essentially the reason is that, with intersection types, we can
  find types such as $Int\&Bool$, which are not bottom-like, but
  are common subtypes of $Int$ and $Bool$. Explain things carefully starting
  from explaining the idea of the old notion of disjointness using bottom-like
types, and then how intersection types mess this up.}

\noindent Bottom-like types behave like $[[Bot]]$ type and are discussed in \Cref{sec:union:disj}.
Disjointness in \Cref{sec:union} depends upon bottom-like types because two types are disjoint
only if their common subtypes are bottom-like. This definition no longer works with the
addition of intersection types. For example, common subtypes of type $[[Int]]$ and
type $[[Bool]]$ also include $[[Int /\ Bool]]$ with the addition of intersection types.
But $[[Int /\ Bool]]$ is not a bottom-like type. So the disjointness definition fails.
Reader may think at this point to add intersection of non-overlapping types such as $[[Int /\ Bool]]$
in bottom-like types to solve the problem. But this imposes additional complexities of mutually
dependent definitions and makes completeness challenging or even impossible to prove.
Another possible solution for this is to add a subtyping rule which makes intersection of
disjoint types to be subtype of $[[Bot]]$ type as in \cite{}. 
This also complicates the system because
it adds mutual dependency of subtyping and disjointness.


\paragraph{Disjointness based on Ordinary Types to the Rescue}
\bruno{Continue the story from the previous paragraph and explain
  how oprdinary types are helpful to avoid the issues with the previous
notion of disjointness.}
\baber{declarative and specifications used. Need to be consistent.}
%Disjointness \cref{def:union:disj} no longer works for \cal with intersection types as discussed in
%\Cref{sec:union:discussion}.
Ordinary types play key role in disjointness of \cal with intersection types.
We extend our previous example of type $[[Int]]$ and type $[[Bool]]$ and show how
disjointness based upon oridnary types categorize them as disjoint types.
An important observation at this point is common subtypes of type $[[Int]]$ and type $[[Bool]]$
cannot include either $[[Int]]$ or $[[Bool]]$. Problamatic types are the intersection types
such as $[[Int /\ Bool]]$. We empahsize the point that ordinary types in \cal does not contain
intersection types. Further, all ordinary types are non-overlapping in \cal.
Therefore, now we say that
two types are disjoint if they do not have any common ordinary subtype. $[[Int]]$ and $[[Bool]]$
do not have any common ordinary subtype. Therefore, $[[Int]]$ and $[[Bool]]$ are disjoint types.
\Cref{def:inter:disj} shows the declarative disjointness for \cal with intersection types:

\begin{definition}
\label{def:inter:disj}
  A $*_s$ B $\Coloneqq$ $\forall$ C, \ $[[ordinary C]]$ \ $\rightarrow$ \ $\neg$ \ ($[[C <: A]]$ and $[[C <: B]]$).
\end{definition}

\noindent Two types $[[A]]$ and $[[B]]$ are
disjoint if the two types $[[A /\ B]]$ do
not have any common ordinary subtype. For example, $[[Int]]$ and $[[A -> B]]$
are disjoint types because there is no ordinary type that is a subtype
of both types.  \Cref{def:inter:disj} is the same as 
\Cref{def:union:disj1}. However, while the \Cref{def:union:disj1} in \Cref{sec:union:discussion}
is equivalent the definition of disjointness using bottom-like types (\Cref{def:union:disj}),
in the calculus with intersection types that is no longer the case. We elaborate 
\Cref{def:inter:disj} on few examples:

\begin{enumerate}
  \item $\boldsymbol{A = [[Int]], \ B = \ [[A -> B]]:}$ \\
        Since there is no ordinary type that is subtype of both $[[Int]]$ and $[[A -> B]]$.
        Therefore, $[[Int]]$ and $[[A -> B]]$ are disjoint types.
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Bot]]:}$ \\
        Since there is no ordinary type that is subtype of both $[[Int]]$ and $[[Bot]]$.
        Therefore, $[[Int]]$ and $[[Bot]]$ are disjoint types.
        In general, type $[[Bot]]$ is disjoint to all types because $[[Bot]]$ type does not
        have any ordinary subtype.
  \item $\boldsymbol{A = [[Int /\ A -> B]], \ B = \ [[Int]]:}$ \\
        Since there is no ordinary type that is subtype of both $[[Int /\ A -> B]]$ and $[[Int]]$.
        Therefore, $[[Int /\ A -> B]]$ and $[[Int]]$ are disjoint types.
        In general, intersection type of two disjoint types which is $[[Int /\ A -> B]]$ in this case,
        is always disjoint to all types.
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Top]]:}$ \\
        In this case, $[[Int]]$ and $[[Top]]$ share a common ordinary subtype which is $[[Int]]$.
        Therefore, $[[Int]]$ and $[[Top]]$ are not disjoint types.
\end{enumerate}

%The
%reason we did not write intersection in \Cref{def:union:disj1} is
%because we do not have intersection types in \cal discussed in
%\Cref{sec:union}.
%Updated disjointness specifications are now
%represented as $[[A *s B]]$ and not $[[A]]$ $*_{s1}$ $[[B]]$.

\subsection{Algorithmic Disjointness}

The change in the disjointness specification has an impact on an algorithmic
formulation of disjointness. Attempting to adapt the algorithmc formulation
in \Cref{sec:union} is problematic. In particular it is hard to obtain
completeness. Therefore, to obtain a sound, complete and decidable
formulation of disjointness we employ the novel notion of
\emph{lowest ordinary subtypes}.

\paragraph{Lowest Ordinary Subtypes ($[[findsubtypes A]]$)}
\Cref{fig:inter:system} shows the definition of
lowest ordinary subtypes ($[[findsubtypes A]]$), which we denote as LOS.
LOS are defined as a function which
returns a list of ordinary subtypes of the given input type.  Ordinary
subtypes of $[[Top]]$ are $[[Int]]$ and $[[Top -> Bot]]$.
No ordinary type is subtype of $[[Bot]]$ type. Ordinary
subtype of $[[Int]]$ is $[[Int]]$ itself. The function case is
interesting. Since no two functions are disjoint in the calculus
proposed in this paper.\bruno{We should make sure that disjointness of functions
is well-explained in Section 3.}
Therefore, the case for function types $[[A -> B]]$ returns $[[Top
    -> Bot]]$ which is the least ordinary function type, which is subtype
of all function types. In the case of union types $[[A \/ B]]$, the
algorithm is called recursively on $[[A]]$ and $[[B]]$ and applies set union
operation on both results from $[[findsubtypes A]]$ and
$[[findsubtypes B]]$. Whereas, in case of intersection types $[[A
    /\ B]]$, algorithm is called recursively on $[[A]]$ and $[[B]]$
and applies set intersection on both results from
$[[findsubtypes A]]$ and $[[findsubtypes B]]$.
Note that LOS is defined as a structurally recursive function and therefore
decidability is straightforward.

\paragraph{Algorithmic Disjointness}
With LOS, it is straightforward to give an algorithmic formulation of
disjointness:
%Since we gave a new definition for declarative disjointness.
%Therefore, we define a new algorithm for disjointness as shown in \Cref{def:inter:ad}.

\begin{definition}
\label{def:inter:ad}
%\texttt{`abc \textasciigrave abc}
  A $*_a$ B $\Coloneqq$  $ [[findsubtypes A]] \cap [[findsubtypes B]] $ = \{\}.
\end{definition}

\noindent The algorithmic formulation of disjointness in
\emph{lowest ordinary subtypes}\Cref{def:inter:ad} states that two
\emph{lowest ordinary subtypes}types
$[[A]]$ and $[[B]]$ are disjoint
if they do not have any common lowest ordinary subtypes. That is the
set intersection of $[[findsubtypes A]]$ and $[[findsubtypes B]]$ is the empty set.
%In simple words,
%two types $[[A]]$ and $[[B]]$ are disjoint if they do not share any common ordinary subtype because
%$FindSubTypes$ ($[[findsubtypes A]]$) returns a set of ordinary subtypes.
Note that this algorithm in \Cref{def:inter:ad} is naturally very close to \Cref{def:inter:disj}.
We illustrate \Cref{def:inter:ad} with a few examples:

\begin{enumerate}
  \item $\boldsymbol{A = [[Int]], \ B = \ [[A -> B]]:}$ \\
        $[[findsubtypes Int]]$ returns \{$[[Int]]$\} and $[[findsubtypes A -> B]]$ returns
        \{$[[Top -> Bot]]$\}. Set intersection of \{$[[Int]]$\} and \{$[[Top -> Bot]]$\} is
        empty set \{\}. Therefore, $[[Int]]$ and $[[A -> B]]$ are disjoint types.
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Bot]]:}$ \\
        $[[findsubtypes Int]]$ returns \{$[[Int]]$\} and $[[findsubtypes Bot]]$ returns
        \{\}. Set intersection of \{$[[Int]]$\} and \{\} is
        empty set \{\}. Therefore, $[[Int]]$ and $[[Bot]]$ are disjoint types.
        In general, type $[[Bot]]$ is disjoint to all types because $[[findsubtypes Bot]]$
        will always return \{\} and intersection of \{\} with all other sets is \{\}.
  \item $\boldsymbol{A = [[Int /\ A -> B]], \ B = \ [[Int]]:}$ \\
        $[[findsubtypes Int /\ A -> B]]$ returns \{\} and $[[findsubtypes Int]]$ returns
        \{$[[Int]]$\}. Set intersection of \{\} and \{$[[Int]]$\} is
        empty set \{\}. Therefore, $[[Int /\ A -> B]]$ and $[[Int]]$ are disjoint types.
        In general, intersection type of two disjoint types which is $[[Int /\ A -> B]]$ in this case,
        is always disjoint to all types.
  \item $\boldsymbol{A = [[Int]], \ B = \ [[Top]]:}$ \\
        $[[findsubtypes Int]]$ returns \{$[[Int]]$\} and $[[findsubtypes Top]]$ returns
        \{$[[Int]]$, $[[Top -> Bot]]$\}.
        Set intersection of \{$[[Int]]$\} and \{$[[Int]]$, $[[Top -> Bot]]$\} is
        set \{$[[Int]]$\}. Therefore, $[[Int]]$ and $[[Top]]$ are not disjoint types.
\end{enumerate}

\paragraph{Soundness and Completeness}
Algorithmic disjointness is sound and complete with respect to declarative disjointness.

\begin{lemma}[Disjointness Soundness]
  If \ $[[A * B]]$ \ then \ $[[A *s B]]$.
\label{lemma:inter:disj-sound}
\end{lemma}
\snow{I thinkthe colon after ``then'' is redundant.}
\baber{Sure, I removed colon after then in all lemmas.}

\begin{lemma}[Disjointness Completeness]
  If \ $[[A *s B]]$ \ then \ $[[A * B]]$.
\label{lemma:inter:disj-complete}
\end{lemma}

\baber{I think we may want to show the proofs for soundness and completeness for this section?}
\bruno{Perhaps, if the proofs are simple enough (or we have space) we can discuss}

\subsection{Disjointness in Ceylon}
\label{sec:inter:ceylon}
Ceylon also provides a notion of disjoint types in type-based case analysis. In this section
we compare the disjointness provided by Ceylon with our disjointness definition.
To start with a very simple Ceylon example:

\begin{lstlisting}[xleftmargin=.2\textwidth, xrightmargin=.2\textwidth,language=Java,caption=Ceylon disjointness code example]
//speak function will not type check
void speak(Person | Student val) {
  switch (val)
  case (is Person) {print("person speaks");}
  case (is Student) {print("student speaks");} 
}
\end{lstlisting}

\noindent The function \emph{speak} will not type check in Ceylon. Because \emph{Person} and
\emph{Student} are not disjoint types. \emph{Person} and \emph{Student} both have a common
subtype which is \emph{Student}. \cal will also reject such programs.
Difference between the disjointness in Ceylon and \cal is that
Ceylon does not provide
a formal disjointness definition, whereas \cal provides a formal definition for
disjointness. Next, we compare a few textual descriptive points of disjointness in Ceylon with
the disjointness definition in \cal. Following points are copied from Ceylon
documentation \cite{}. Two types X and Y are disjoint if either of the following holds:

\begin{enumerate}
  \item{X is a subtype of a type A and Y is a subtype of a type B, where A and B are distinct cases of an enumerated type}
  \item{X and Y are both classes and X is not a subclass of Y and Y is not a subclass of X}
  \item{X is a union type $[[A \/ B]]$ and both Y and A are disjoint and Y and B are disjoint}
  \item{X is an enumerated type with cases A1|A2|... and for every case Ai of X, Y and Ai are disjoint}
  \item{X is an intersection type $[[A/\B]]$ and either Y and A are disjoint or Y and B are disjoint, or}
\end{enumerate}

\noindent All these points are trivially covered by our formal disjointness \Cref{def:inter:disj}.
Formal definitions are easy to reason about than textual descriptions.