\section{Overview}
\label{sec:overview}

\bruno{I'm sketching a possible structure, but it can be changed ofcourse.}

\subsection{Tagged Union Types}

% Brief intro to union types and one or 2 simple examples that show that we
% can automatically lift values into union type without the need of some
% tag/constructor. Something like:

\ningning{where is syntax highlighting for code? Also probably remove line numbers.}

Union types have been studied intensively in the literature [?]. In particular,
an expression with type $[[A\/B]]$ can be consider to have either type $[[A]]$
\textit{or} type $[[B]]$. Many systems [?] model \textit{tagged union types}
(also called \textit{sum types} or \textit{variants records}),
where explicit \textit{tags} are used to construct terms with union types. For
example, with $\mathsf{inj_1} :: [[A -> A \/ B]]$ and $\mathsf{inj_2} :: [[B ->
A \/ B]]$, we have

\begin{lstlisting}
inj1 "foo": String | Int
inj2 1 : String | Int
\end{lstlisting}

For example, using tagged union types, we can implement safe division as:

\begin{lstlisting}
function safediv (x : Int) (y : Int) : String | Int =
  if (y == 0) then inj1 "Divided by zero"
  else inj2 (x / y)
\end{lstlisting}

Tagged union types are eliminated by \lstinline{case} statements. For example,
we can write the following program, which has different behaviors depending on the
tag of \lstinline{x}, where \lstinline{show} takes an \lstinline{Int} and
returns back its string representation.

\ningning{maybe use \lstinline{switch} for all case analysis?}

\begin{lstlisting}
function tostring (x: String | Int) : String =
  case x of
    inj1 str -> str
    inj2 num -> show num
\end{lstlisting}

Combining union type construction in \lstinline{safediv} and its elimination in
\lstinline{tostring}, we can easily implement an interface which returns the
result of safe division as one \lstinline{String}.

\begin{lstlisting}
> tostring (safediv 42 2)
"21"
> tostring (safe 42 0)
"Divided by zero"
\end{lstlisting}


\subsection{Type-directed Elimination of Union Types}

% Motivate the need for having a construct that can eliminate union types,
% perhaps trying to use an example where the String above would be a kind
% of exception, and the Int would be regular computation. Alternatively
% find an existing example from the literature.

% Discussing existing approaches for eliminating union types;
% point out that elimination constructs based on types (our focus) vs
% elimination constructs based on tags (which are used in algebraic
% datatypes or polymorphic variants (like in OCaml)).
% The focus should be on type-based approaches.

% Try to identify some limitations/problems. For instance how to deal
% with ambiguity (just use order? restrict the construct somehow ...).


While tags are useful to make it explicit which type a value belongs to, they
also add clutter in the programs, and usually require extra space to store the tags. On
the other hand, in systems with subtyping for union types [?], explicit tags are
replaced by implicit coercions represented by the two subtyping rules $[[A <: A \/
B]]$ and $[[B <: A \/ B]]$. We call such types \textit{untagged union types}, or
simply \textit{union types}. In those systems, a term of type $[[A]]$ or $[[B]]$
can be directly used as if it had type $[[A \/ B]]$, and we can model safe
division as

\begin{lstlisting}
function safediv2 (x : Int) (y : Int) : String | Int =
  if (y == 0) then "Divided by zero"
  else (x / y)
\end{lstlisting}

Now elimination of union types cannot reply on tags anymore. Instead, for
union types, elimination is often \textit{type-directed} [?]. For instance,
\lstinline{tostring2} have different behaviors depending on the \textit{type} of
\lstinline{x}.

\begin{lstlisting}
function tostring2 (x: String | Int) : String =
  case x of
    String -> x
    Int -> show x
\end{lstlisting}

\noindent Note here \lstinline{show} is directly applied to \lstinline{x}, as
the type-directed elimination \textit{refines} the type of \lstinline{x} from
\lstinline{String | Int} to \lstinline{Int} in the second branch.

However, compared to tagged union types, extra care must to taken with
elimination of union types. In particular, ambiguity may arise when types in a
union type overlap. For example, consider the type \lstinline{Person | Student},
where we assume \lstinline{Student} is a subtype of \lstinline{Person}. Tagged
union types can easily distinguish the two types by looking at the tag:

\begin{lstlisting}
function isstudent (x: Person | Student) : Bool =
  case x of
    inj1 person -> False
    inj2 student -> True
\end{lstlisting}

But if we apply the straightforward transformation of this function using union
types and type-directed elimination, we will get:

\begin{lstlisting}
function isstudent2 (x: Person | Student) : Bool =
  case x of
    Person  -> False
    Student -> True
\end{lstlisting}

\noindent Now it is unclear what would happen if we apply \lstinline{isstudent2}
to a term of \lstinline{Student}, as the term matches both branches. In some
systems [?], the choice is not decided in the semantics, in the sense either
branch can be chosen, which leads to \textit{incoherent} behaviors. In some
other systems [?], branches are inspected from top to bottom, and the first one
that matches the type gets chosen. However, in those systems, as
\lstinline{Person} is a supertype of \lstinline{Student}, the first branch
subsumes the second one and will always get chosen, and so the second branch
will never get evaluated!


\subsection{Eliminating Union Types in Ceylon}
Ceylon supports type-directed union elimination via the switch/case expression.
It has multiple branches. Each is annotated by a type and contains a function.
Together the overloaded function is applied to a input.
The input has an union type statically.
But its runtime type can only fit in one branch.
That makes it different to the previous discussion. Why?
Because the type annotation of any two branches must be disjoint.

\begin{lstlisting}
  switch (v)
    case (is String) { print("String: ``v``"); }
    case (is Integer) { print("Integer: ``v``"); }
    case (is Float) { print("Float: ``v``"); }
\end{lstlisting}
% https://ceylon-lang.org/documentation/1.3/tour/types/
% case (is Object) { print(v); }
% case (is Nothing) { print("nothing"); }

Being disjoint means it is impossible to find a value that matches with both.
Each of \lstinline{Integer}, \lstinline{Char}, and \lstinline{String} is
disjoint to others.
% Ensured by Ceylon's type system, \lstinline{v} of type \lstinline{Void} can 
% either be an \lstinline{Object} or \lstinline{Nothing}. 
Thurs there is no need to use the order of branches to decide
a program's behavior, and users can totally ignore the order.
Take the previous function \lstinline{isstudent2} as an example.
For its definition to be accepted by Ceylon,
\lstinline{Person} and \lstinline{Student} cannot be subclass of
each other, assuming they are classes.
Since Ceylon does not allow multiple inheritance on class,
the restriction is sufficient to prevent the incoherent scenario.
In the runtime, type of the input must be a subtype of either \lstinline{Person} 
or \lstinline{Student}. According to the subtyping relation,
one branch will be chosen and the input term will be cast
and substituted in.
%
Besides primitive types and classes, 
distinct members in an enumerated type are also viewed as disjoint.
% switch/case also handles other types as long as they are disjoint.
% Some primitive types like \lstinline{Integer}, \lstinline{Char}, and 
% \lstinline{String} are disjoint to others.
%
Forcing all cases in one switch/case expression to be disjoint makes them
interchangeable.
That could reduce confusion of program readers and eliminate a potential
source of bugs.

\begin{lstlisting}
	void <A> printA(A|Null x) {
		switch (x)
		case (is A) { print("an A"); }
		case (is Null) { print("nothing"); }
	}
\end{lstlisting}

For instance, one might expect the second branch to be executed if the above
function takes \lstinline{null} as input.
However, without the disjointness constraint, \lstinline{A} might be nullable itself.
An example is using \lstinline{Integer|Null} to denote a number or infinity
as a division result.
In that case the second branch is always shadowed by the first one.
Note that swapping the two cases cannot prevent all unexpected behaviors.
When the outside \lstinline{Null} has a different meaning other than infinity,
they are not distinguishable, and the branch designed for it will take them all.
% And instead of \lstinline{print}, one might call a function that takes care
% of \lstinline{Nothing} and the other component in \lstinline{A}.
This problem is even more serious when the language implements some syntax
sugar or encode other features via the switch/case construct.
It could be convenient to have a simple construct for unwrapping \lstinline{A|Null} without writing down the full switch/case expression.
But once the details are hidden, users may not be able to image that how does
the order affects the program, as we discussed above.  
On the other hand, with some requirements on the argument and return types, it is 
straightforward to support function overloading by combining them in a switch/case expression.
But it will be hard to find a fair criteria to decide which one
should be prioritized, if two functions can overlap.
% https://github.com/ceylon/ceylon-spec/issues/50
% https://github.com/ceylon/ceylon-spec/issues/65

\begin{lstlisting}
void printAfterPlusOne(Integer|String x) {
	switch (x)
	case (is Integer|Float) { print(x+1); }
	case (is String) { print("String:"+x); }
}
\end{lstlisting}

Although the list of cases must be exhaustive, it does need to
strictly follow the input's type.
For example, in the above function, \lstinline{x} can only be an integer
or a string. But it is not harmful for the first branch to expect
a term of \lstinline{Integer|Float}, since any integer can have such
type.
In general, a term of type $A$ is always assignable to any supertype of $A$.
But in Ceylon, the checking of assignability is not complete to
subtyping.
Although the subtyping relation holds between \lstinline{v}'s
(declarative) type and \lstinline{Integer}, \lstinline{v}
is not assignable to \lstinline{Integer}, and the following program
cannot be accepted by Ceylon's compiler.
% https://try.ceylon-lang.org/#

\begin{lstlisting}
	< Character | Integer > & < String | Integer > v = 100;
	switch (v)
	case (is Integer) { print("Integer: ``v``"); }
\end{lstlisting}

To dig deeper for disjointness, it often comes to the the concept
of \emph{bottom type}.
Bottom type is a subtype of all types, in contrast to the top type.
Certainly the bottom type has no value.
In Ceylon, it is called \lstinline{Nothing}, representing the empty set.
%
With the existence of subtyping, a branch in switch/case expression
can take a term of a subtype of its expected type.
If the term's type is also a subtype of the other branch's expected
type, type information will be insufficient to disambiguate.
To prevent this, disjoint types cannot have any common subtype which has
inhabited values.
For two disjoint types $[[A]]$ and $[[B]]$, their intersection $[[A/\B]]$
is naturally a common subtype, and therefore must be equivalent to
the bottom type \lstinline{Nothing}.

\begin{comment}
Let us call them \emph{bottom-like types}.
% Ceylon treat such types specially.
In a switch construct, every case has a type annotation.
In Ceylon, this type annotation is not allowed to be bottom-like.
The compiler uses this type to narrow the static type of the input term
in switch/case, and rejects the program if the resultant type is equivalent
to \lstinline{Nothing}.

\begin{verbatim}
	Known problem in Ceylon:
	(Int | String) & (Int | Char) & (Char | String) is not treated as a bottom-like type
	
	Potential reason:
	It defines bottom-like as:
	Bottom-like A\& B ::= A * B
	And it doesn't recognize intersection of unions and union of intersection,
	which is the oopsla18 paper claims to have.
	
	Possible consequences:
	- [harmless] we can write a case branch for such type.
	- The definition of disjointness might be not so presice
	
	
	alias IoC => Integer | Character;
	alias IoS => Integer | String;
	alias CoS => Character | String;
	alias Bot => IoC & IoS & CoS;
	// Ceylon does not treat Bot as Bottom-like type
	
	void test(Integer | Bot v){
		switch (v)
		case (is Integer) {}
		case (is Bot) {}
	}
	void test2(Integer | Integer&Character v){
		switch (v)
		case (is Integer) {}
		//    case (is Integer&Character ) {}
	}
	
	
	< Character | Integer > & < String | Integer > v2 = 100;
	switch (v2)
	// case (is Character | String ) { print("String: ``v2``"); }
	case (is Integer) { print("Integer: ``v2``"); }
	
	// <Character|Integer>&<String|Integer> is covered by, but not assignable to, the type Integer (explicitly narrow assigned expression using of Integer)
	
	
	// accepted
	alias IntLike =>  < Character | Integer > & < String | Integer >;
	IntLike v1 = 100;
	switch (v1)
	case (is Integer) { print("Integer: ``v1``"); }
	
	// rejected
	// Specified expression must be assignable to declared type: the assigned type <Character|Integer>&<String|Integer> is covered by, but not assignable to, the type Integer (explicitly narrow assigned expression using of Integer)
	 < Character | Integer > & < String | Integer > v2 = 100;
	switch (v2)
	case (is Integer) { print("Integer: ``v2``"); }
	
	
	// accepted
	alias Bot2 => Nothing;
	Nothing | Integer v3 = 1;
	switch (v3)
	case (is Bot2) { print("test2"); }
	case (is Integer) { print("test2"); }
	
	// rj
	// Narrows to bottom type Nothing: Nothing has empty intersection with Nothing|Integer
	 Nothing | Integer v3 = 1;
	switch (v3)
	case (is Nothing) { print("test2"); }
	case (is Integer) { print("test2"); }
	
	
	alias IoC => Integer | Character;
	alias IoS => Integer | String;
	alias CoS => Character | String;
	alias Bot => IoC & IoS & CoS;
	
	// ac
	<IoC & IoS & CoS> | Integer v3 = 1;
	switch (v3)
	case (is Bot) { print("test"); }
	case (is Bot2) { print("test"); }
	case (is Integer) { print("test"); }
	
	// rj
	// Narrows to bottom type Nothing: IoC&IoS&CoS has empty intersection with IoC&IoS&CoS|Integer
	switch (v3)
	case (is IoC & IoS & CoS) { print("test"); }
	case (is Integer) { print("test"); }
	
\end{verbatim}
\end{comment}

\bruno{
	Introduce the Ceylon approach with examples; introduce the idea of
	disjointness informally; contrast with existing constructs.
	Try to motivate the adapotion of disjointness (this should be discussed
	in the Ceylon documentation to some extent).\\
	Here it is important to give representative examples (look at documentation
	and/or other online resources), including examples
	that demonstrate how Ceylon uses union types to model overloaded functions.
}

\subsection{Our work}

\snow{Some concerns: does the addition of intersection types and distributivity
	really increase the expressiveness of the system?
	Currently the only interesting intersection type has the form of (A->B) \& (C->D),
	like (int->bool)\&(bool->int).
	But there is no way to construct a term of such type.
	The closest thing is $\lambda$ x.x, which has (int->int)\&(bool->bool).}

\bruno{
	Introduce our work, setting the goal to study the construct formally.
	Connect with the work on disjoint intersection types, which also
	employs a notion of disjointness, but for intersection. Explain that
	what is needed is a dual notion of disjointness.\\
	Introduce the first calculus, and explain that it is directly inspired
	by a dual notion of discjointness.\\
	Introduce the second calculus and identify a technical challenge with
	disjointness: the addition of intersection types breaks the previous
	notion of disjointness. Introduce the novel way to find disjoint types.\\
	Summarize/mention key results: type-safety; soundness/completeness of
	disjointness; determinism.\\
	Perhaps here it is also useful to identity, together with Baber, what
	were the most challenging aspects in the formalization, and maybe
	highlight these.
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% org-ref-default-bibliography: "../paper.bib"
%%% End: