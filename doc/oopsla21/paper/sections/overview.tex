\section{Overview}
\label{sec:overview}

\bruno{I'm sketching a possible structure, but it can be changed ofcourse.}

\subsection{Tagged Union Types}

% Brief intro to union types and one or 2 simple examples that show that we
% can automatically lift values into union type without the need of some
% tag/constructor. Something like:

\ningning{where is syntax highlighting for code? Also probably remove line numbers.}

Union types have been studied intensively in the literature [?]. In particular,
an expression with type $[[A\/B]]$ can be consider to have either type $[[A]]$
\textit{or} type $[[B]]$. Many systems [?] model \textit{tagged union types}
(also called \textit{sum types} or \textit{variants records}),
where explicit \textit{tags} are used to construct terms with union types. For
example, with $\mathsf{inj_1} :: [[A -> A \/ B]]$ and $\mathsf{inj_2} :: [[B ->
A \/ B]]$, we have

\begin{lstlisting}
inj1 "foo": String | Int
inj2 1 : String | Int
\end{lstlisting}

For example, using tagged union types, we can implement safe division as:

\begin{lstlisting}
function safediv (x : Int) (y : Int) : String | Int =
  if (y == 0) then inj1 "Divided by zero"
  else inj2 (x / y)
\end{lstlisting}

Tagged union types are eliminated by \lstinline{case} statements. For example,
we can write the following program, which has different behaviors depending on the
tag of \lstinline{x}, where \lstinline{show} takes an \lstinline{Int} and
returns back its string representation.

\ningning{maybe use \lstinline{switch} for all case analysis?}

\begin{lstlisting}
function tostring (x: String | Int) : String =
  case x of
    inj1 str -> str
    inj2 num -> show num
\end{lstlisting}

Combining union type construction in \lstinline{safediv} and its elimination in
\lstinline{tostring}, we can easily implement an interface which returns the
result of safe division as one \lstinline{String}.

\begin{lstlisting}
> tostring (safediv 42 2)
"21"
> tostring (safe 42 0)
"Divided by zero"
\end{lstlisting}


\subsection{Type-directed Elimination of Union Types}

% Motivate the need for having a construct that can eliminate union types,
% perhaps trying to use an example where the String above would be a kind
% of exception, and the Int would be regular computation. Alternatively
% find an existing example from the literature.

% Discussing existing approaches for eliminating union types;
% point out that elimination constructs based on types (our focus) vs
% elimination constructs based on tags (which are used in algebraic
% datatypes or polymorphic variants (like in OCaml)).
% The focus should be on type-based approaches.

% Try to identify some limitations/problems. For instance how to deal
% with ambiguity (just use order? restrict the construct somehow ...).


While tags are useful to make it explicit which type a value belongs to, they
also add clutter in the programs, and usually require extra space to store the tags. On
the other hand, in systems with subtyping for union types [?], explicit tags are
replaced by implicit coercions represented by the two subtyping rules $[[A <: A \/
B]]$ and $[[B <: A \/ B]]$. We call such types \textit{untagged union types}, or
simply \textit{union types}. In those systems, a term of type $[[A]]$ or $[[B]]$
can be directly used as if it had type $[[A \/ B]]$, and we can model safe
division as

\begin{lstlisting}
function safediv2 (x : Int) (y : Int) : String | Int =
  if (y == 0) then "Divided by zero"
  else (x / y)
\end{lstlisting}

Now elimination of union types cannot reply on tags anymore. Instead, for
union types, elimination is often \textit{type-directed} [?]. For instance,
\lstinline{tostring2} have different behaviors depending on the \textit{type} of
\lstinline{x}.

\begin{lstlisting}
function tostring2 (x: String | Int) : String =
  case x of
    String -> x
    Int -> show x
\end{lstlisting}

\noindent Note here \lstinline{show} is directly applied to \lstinline{x}, as
the type-directed elimination \textit{refines} the type of \lstinline{x} from
\lstinline{String | Int} to \lstinline{Int} in the second branch.

However, compared to tagged union types, extra care must to taken with
elimination of union types. In particular, ambiguity may arise when types in a
union type overlap. For example, consider the type \lstinline{Person | Student},
where we assume \lstinline{Student} is a subtype of \lstinline{Person}. Tagged
union types can easily distinguish the two types by looking at the tag:

\begin{lstlisting}
function isstudent (x: Person | Student) : Bool =
  case x of
    inj1 person -> False
    inj2 student -> True
\end{lstlisting}

But if we apply the straightforward transformation of this function using union
types and type-directed elimination, we will get:

\begin{lstlisting}
function isstudent2 (x: Person | Student) : Bool =
  case x of
    Person  -> False
    Student -> True
\end{lstlisting}

\noindent Now it is unclear what would happen if we apply \lstinline{isstudent2}
to a term of \lstinline{Student}, as the term matches both branches. In some
systems [?], the choice is not decided in the semantics, in the sense either
branch can be chosen, which leads to \textit{incoherent} behaviors. In some
other systems [?], branches are inspected from top to bottom, and the first one
that matches the type gets chosen. However, in those systems, as
\lstinline{Person} is a supertype of \lstinline{Student}, the first branch
subsumes the second one and will always get chosen, and so the second branch
will never get evaluated!


\subsection{Eliminating Union Types in Ceylon}

Introduce the Ceylon approach with examples; introduce the idea of
disjointness informally; contrast with existing constructs.
Try to motivate the adapotion of disjointness (this should be discussed
in the Ceylon documentation to some extent).

Here it is important to give representative examples (look at documentation
and/or other online resources), including examples
that demonstrate how Ceylon uses union types to model overloaded functions.

\subsection{Our work}

\snow{Some concerns: does the addition of intersection types and distributivity
  really increase the expressiveness of the system?
  Currently the only interesting intersection type has the form of (A->B) \& (C->D),
  like (int->bool)\&(bool->int).
  But there is no way to construct a term of such type.
  The closest thing is $\lambda$ x.x, which has (int->int)\&(bool->bool).}

Introduce our work, setting the goal to study the construct formally.
Connect with the work on disjoint intersection types, which also
employs a notion of disjointness, but for intersection. Explain that
what is needed is a dual notion of disjointness.

Introduce the first calculus, and explain that it is directly inspired
by a dual notion of discjointness.

Introduce the second calculus and identify a technical challenge with
disjointness: the addition of intersection types breaks the previous
notion of disjointness. Introduce the novel way to find disjoint types.

Summarize/mention key results: type-safety; soundness/completeness of
disjointness; determinism.

Perhaps here it is also useful to identity, together with Baber, what
were the most challenging aspects in the formalization, and maybe
highlight these.

\baber{This section will give an overview.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% org-ref-default-bibliography: "../paper.bib"
%%% End: