\section{Overview}
\label{sec:overview}

\bruno{I'm sketching a possible structure, but it can be changed ofcourse.}

\ningning{We may want to be consistent with the syntax used in examples. Now
  there are three things going on: examples before introducing Ceylon; examples
  in Ceylon; examples in our calculi. Will it look confusing as we use three
  different syntax rules?}

\subsection{Tagged Union Types}

% Brief intro to union types and one or 2 simple examples that show that we
% can automatically lift values into union type without the need of some
% tag/constructor. Something like:

We start with a brief introduction to union types. An expression has a union
type $[[A\/B]]$, if it can be considered to have either type $[[A]]$ \textit{or}
type $[[B]]$. Many systems  model \textit{tagged union types} (also called
\textit{sum types} or \textit{variants records}), where explicit \textit{tags}
are used to construct terms with union types. Two introduction forms
$\mathsf{inj_1} :: [[A -> A \/ B]]$ turns the type of an expression of type
$[[A]]$ into type $[[A \/ B]]$, and $\mathsf{inj_2} :: [[B -> A \/ B]]$
turns the type of an expressions of type $[[B]]$ into type $[[A \/ B]]$.

\begin{lstlisting}
inj1 "foo": String | Int
inj2 1 : String | Int
\end{lstlisting}

Using tagged union types, we can implement safe division as:

\begin{lstlisting}
function safediv (x : Int) (y : Int) : String | Int =
  if (y == 0) then inj1 "Divided by zero"
  else inj2 (x / y)
\end{lstlisting}

Tagged union types are eliminated by \lstinline{switch} statements. For example,
the following program \lstinline{tostring} has different behaviors depending on the
tag of \lstinline{x}, where \lstinline{show} takes an \lstinline{Int} and
returns back its string representation.

\begin{lstlisting}
function tostring (x: String | Int) : String =
  switch x of
    inj1 str -> str
    inj2 num -> show num
\end{lstlisting}

Combining union type construction in \lstinline{safediv} and its elimination in
\lstinline{tostring}, we can easily implement an interface which returns the
result of safe division as one \lstinline{String}.

\begin{lstlisting}
> tostring (safediv 42 2)
"21"
> tostring (safe 42 0)
"Divided by zero"
\end{lstlisting}


\subsection{Type-directed Elimination of Union Types}

% Motivate the need for having a construct that can eliminate union types,
% perhaps trying to use an example where the String above would be a kind
% of exception, and the Int would be regular computation. Alternatively
% find an existing example from the literature.

% Discussing existing approaches for eliminating union types;
% point out that elimination constructs based on types (our focus) vs
% elimination constructs based on tags (which are used in algebraic
% datatypes or polymorphic variants (like in OCaml)).
% The focus should be on type-based approaches.

% Try to identify some limitations/problems. For instance how to deal
% with ambiguity (just use order? restrict the construct somehow ...).


While tags are useful to make it explicit which type a value belongs to, they
also add clutter in the programs, and usually require extra space to store the
tags. On the other hand, in systems with subtyping for union types
\cite{dunfield2014elaborating,pierce1991programming,muehlboeck2018empowering},
explicit tags are replaced by implicit coercions represented by the two
subtyping rules $[[A <: A \/ B]]$ and $[[B <: A \/ B]]$. We call such types
\textit{untagged union types}, or simply \textit{union types}. In those systems,
a term of type $[[A]]$ or $[[B]]$ can be directly used as if it had type $[[A \/
B]]$, and thus we can model safe division as

\begin{lstlisting}
function safediv2 (x : Int) (y : Int) : String | Int =
  if (y == 0) then "Divided by zero"
  else (x / y)
\end{lstlisting}

However, now elimination of union types cannot reply on tags anymore, and
different systems implement elimination differently.


\paragraph{Single branch elimination.}

In \citet{pierce1991programming,dunfield2014elaborating}, the \lstinline{switch}
statement on an expression with a union type $[[A \/ B]]$ supports only one
branch, and the branch needs to have the same type when the expression has type
$[[A]]$, or type $[[B]]$. For example, in \lstinline{tostring2}, the expression
\lstinline{show x} must return \lstinline{String} when \lstinline{x : String},
and when \lstinline{x : Int}, which means \lstinline{show} must be overloaded
(in \citet{pierce1991programming,dunfield2014elaborating}, this can be
implemented by requiring \lstinline{show} to have an \textit{intersection type}).

\begin{lstlisting}
function tostring2 (x: String | Int) : String =
  switch x of
    x -> show x
\end{lstlisting}

This implementation is concise, but it is also restrictive as it can no longer
support multiple branches according to the different representations of
\lstinline{x}.

\paragraph{Type-directed elimination.}

On the other hand, some systems [?] support \textit{type-directed} elimination
of union types. For instance, \lstinline{tostring3} have different behaviors
depending on the \textit{type} of \lstinline{x}.

\begin{lstlisting}
function tostring3 (x: String | Int) : String =
  switch x of
    String -> x
    Int -> show x
\end{lstlisting}

\noindent Note here \lstinline{show} is directly applied to \lstinline{x}, and
it does not need to be overloaded, as the type-directed elimination
\textit{refines} the type of \lstinline{x} from \lstinline{String | Int} to
\lstinline{Int} in the second branch.

However, compared to tag-directed elimination, extra care must to taken with
type-directed elimination. In particular, while we can easily distinguish tags,
in type-directed elimination, ambiguity may arise when types in a union type
overlap. For example, consider the type \lstinline{Person | Student}, where we
assume \lstinline{Student} is a subtype of \lstinline{Person}. With tag-directed
elimination, we can write the following function:

\begin{lstlisting}
function isstudent (x: Person | Student) : Bool =
  switch x of
    inj1 person -> False
    inj2 student -> True
\end{lstlisting}

But if we transform this function straightforwardly to type-directed
elimination, we will get:

\begin{lstlisting}
function isstudent2 (x: Person | Student) : Bool =
  switch x of
    Person  -> False
    Student -> True
\end{lstlisting}

\noindent Now it is unclear what would happen if we apply \lstinline{isstudent2}
to a term of \lstinline{Student}, as its type matches both branches. In some
systems [?], the choice is not decided in the semantics, in the sense either
branch can be chosen, which leads to \textit{incoherent} behaviors. In some
other systems [?], branches are inspected from top to bottom, and the first one
that matches the type gets chosen. However, in those systems, as
\lstinline{Person} is a supertype of \lstinline{Student}, the first branch
subsumes the second one and will always get chosen, and so the second branch
will never get evaluated!


\subsection{Eliminating Union Types in Ceylon}
Ceylon supports type-directed union elimination via the switch/case expression.
It has multiple branches. Each is annotated by a type and contains a function.
Together the overloaded function is applied to a input.
The input has an union type statically.
But its runtime type can only fit in one branch.
That makes it different to the previous discussion. Why?
Because the type annotation of any two branches must be disjoint.

\begin{lstlisting}
  switch (v)
    case (is String) { print("String: ``v``"); }
    case (is Integer) { print("Integer: ``v``"); }
    case (is Float) { print("Float: ``v``"); }
\end{lstlisting}
% https://ceylon-lang.org/documentation/1.3/tour/types/
% case (is Object) { print(v); }
% case (is Nothing) { print("nothing"); }

Being disjoint means it is impossible to find a value that matches with both.
Each of \lstinline{Integer}, \lstinline{Char}, and \lstinline{String} is
disjoint to others.
% Ensured by Ceylon's type system, \lstinline{v} of type \lstinline{Void} can 
% either be an \lstinline{Object} or \lstinline{Nothing}. 
Thurs there is no need to use the order of branches to decide
a program's behavior, and users can totally ignore the order.
Take the previous function \lstinline{isstudent2} as an example.
For its definition to be accepted by Ceylon,
\lstinline{Person} and \lstinline{Student} cannot be subclass of
each other, assuming they are classes.
Since Ceylon does not allow multiple inheritance on class,
the restriction is sufficient to prevent the incoherent scenario.
In the runtime, type of the input must be a subtype of either \lstinline{Person} 
or \lstinline{Student}. According to the subtyping relation,
one branch will be chosen and the input term will be cast
and substituted in.
%
Besides primitive types and classes, 
distinct members in an enumerated type are also viewed as disjoint.
% switch/case also handles other types as long as they are disjoint.
% Some primitive types like \lstinline{Integer}, \lstinline{Char}, and 
% \lstinline{String} are disjoint to others.
%
Forcing all cases in one switch/case expression to be disjoint makes them
interchangeable.
That could reduce confusion of program readers and eliminate a potential
source of bugs.

\begin{lstlisting}
	void <A> printA(A|Null x) {
		switch (x)
		case (is A) { print("an A"); }
		case (is Null) { print("nothing"); }
	}
\end{lstlisting}

For instance, one might expect the second branch to be executed if the above
function takes \lstinline{null} as input.
However, without the disjointness constraint, \lstinline{A} might be nullable itself.
An example is using \lstinline{Integer|Null} to denote a number or infinity
as a division result.
In that case the second branch is always shadowed by the first one.
Note that swapping the two cases cannot prevent all unexpected behaviors.
When the outside \lstinline{Null} has a different meaning other than infinity,
they are not distinguishable, and the branch designed for it will take them all.
% And instead of \lstinline{print}, one might call a function that takes care
% of \lstinline{Nothing} and the other component in \lstinline{A}.
This problem is even more serious when the language implements some syntax
sugar or encode other features via the switch/case construct.
It could be convenient to have a simple construct for unwrapping \lstinline{A|Null} without writing down the full switch/case expression.
But once the details are hidden, users may not be able to image that how does
the order affects the program, as we discussed above.  
On the other hand, with some requirements on the argument and return types, it is 
straightforward to support function overloading by combining them in a switch/case expression.
But it will be hard to find a fair criteria to decide which one
should be prioritized, if two functions can overlap.
% https://github.com/ceylon/ceylon-spec/issues/50
% https://github.com/ceylon/ceylon-spec/issues/65

\begin{lstlisting}
void printAfterPlusOne(Integer|String x) {
	switch (x)
	case (is Integer|Float) { print(x+1); }
	case (is String) { print("String:"+x); }
}
\end{lstlisting}

Although the list of cases must be exhaustive, it does need to
strictly follow the input's type.
For example, in the above function, \lstinline{x} can only be an integer
or a string. But it is not harmful for the first branch to expect
a term of \lstinline{Integer|Float}, since any integer can have such
type.
In general, a term of type $A$ is always assignable to any supertype of $A$.
But in Ceylon, the checking of assignability is not complete to
subtyping.
Although the subtyping relation holds between \lstinline{v}'s
(declarative) type and \lstinline{Integer}, \lstinline{v}
is not assignable to \lstinline{Integer}, and the following program
cannot be accepted by Ceylon's compiler.
% https://try.ceylon-lang.org/#

\begin{lstlisting}
	< Character | Integer > & < String | Integer > v = 100;
	switch (v)
	case (is Integer) { print("Integer: ``v``"); }
\end{lstlisting}

To dig deeper for disjointness, it often comes to the the concept
of \emph{bottom type}.
Bottom type is a subtype of all types, in contrast to the top type.
Certainly the bottom type has no value.
In Ceylon, it is called \lstinline{Nothing}, representing the empty set.
%
With the existence of subtyping, a branch in switch/case expression
can take a term of a subtype of its expected type.
If the term's type is also a subtype of the other branch's expected
type, type information will be insufficient to disambiguate.
To prevent this, disjoint types cannot have any common subtype which has
inhabited values.
For two disjoint types $[[A]]$ and $[[B]]$, their intersection $[[A/\B]]$
is naturally a common subtype, and therefore must be equivalent to
the bottom type \lstinline{Nothing}.

\begin{comment}
Let us call them \emph{bottom-like types}.
% Ceylon treat such types specially.
In a switch construct, every case has a type annotation.
In Ceylon, this type annotation is not allowed to be bottom-like.
The compiler uses this type to narrow the static type of the input term
in switch/case, and rejects the program if the resultant type is equivalent
to \lstinline{Nothing}.
\end{comment}

\bruno{
	Introduce the Ceylon approach with examples; introduce the idea of
	disjointness informally; contrast with existing constructs.
	Try to motivate the adapotion of disjointness (this should be discussed
	in the Ceylon documentation to some extent).\\
	Here it is important to give representative examples (look at documentation
	and/or other online resources), including examples
	that demonstrate how Ceylon uses union types to model overloaded functions.
}

\subsection{Our work}
After seeing the connection between bottom-like types and disjointness,
it is intuitive to formally define disjointness via bottom-like types.

\begin{definition}
	A $*_s$ B $\Coloneqq$ $\forall$ C, $[[C <: A]]$ $\wedge$ $[[C <: B]]$ $\rightarrow$ $[[botlike C]]$
	\label{def:union:disj}
\end{definition}

\snow{Here I copy the definition from union.tex. Maybe we can introduce it
earlier.}

Two types are disjoint if and only if all of their common subtypes are bottom-like.
That is to say, there does not exist any term that is assignable to both of
them.
For the detailed discussion and an algorithmic formalization of
disjointness, please refer to Section~\ref{sec:union:disj}.

\snow{Do we need to compare with intersection disjointness or it will be
distracting?}

\snow{Next: How do we ensure exhaustive? Show the typing rule of switch/case.}

\snow{Next of the next: intersection types and distributivity}

\snow{Some concerns: does the addition of intersection types and distributivity
	really increase the expressiveness of the system?
	Currently the only interesting intersection type has the form of (A->B) \& (C->D),
	like (int->bool)\&(bool->int).
	But there is no way to construct a term of such type.
	The closest thing is $\lambda$ x.x, which has (int->int)\&(bool->bool).}

\bruno{
	Introduce our work, setting the goal to study the construct formally.
	Connect with the work on disjoint intersection types, which also
	employs a notion of disjointness, but for intersection. Explain that
	what is needed is a dual notion of disjointness.\\
	Introduce the first calculus, and explain that it is directly inspired
	by a dual notion of discjointness.\\
	Introduce the second calculus and identify a technical challenge with
	disjointness: the addition of intersection types breaks the previous
	notion of disjointness. Introduce the novel way to find disjoint types.\\
	Summarize/mention key results: type-safety; soundness/completeness of
	disjointness; determinism.\\
	Perhaps here it is also useful to identity, together with Baber, what
	were the most challenging aspects in the formalization, and maybe
	highlight these.
}

In this paper, we follow type-based union elimination similar to Ceylon.
We enforce disjointness constraint on the types of branches of a switch
expression. On the contrary to Ceylon, we provide a formal definition
of disjointness. Our disjointness definition is inspired by $\lambda_{i}$ 
\cite{oliveira2016disjoint}. $\lambda_{i}$ formally defines disjointness
for intersection types and merge operator.
Intersection of two types $[[A]]$ and $[[B]]$ is dijoint in $\lambda_{i}$
if $[[A]]$ and $[[B]]$ do not share a common supertype which is not
\emph{top-like}. So-called \emph{top-like} types are defined in 
\cite{oliveira2016disjoint} and are such types which are \emph{supertypes}
of all other types.

Union types are usually considered to be dual of intersection types.
Therefore, we propose a dual definition of \emph{bottom-like} types.
In contrast to \emph{top-like} types, \emph{bottom-like} types are
subtypes of all other types. Further, in contrast to the disjointness
definition in $\lambda_{i}$, two types $[[A]]$ and $[[B]]$ in the simplest 
caluclus studied in this paper are disjoint if $[[A]]$ and $[[B]]$
do not share any common \emph{subtype} which is not \emph{bottom-like}.
Note that $\lambda_{i}$ proposed \emph{top-like} with \emph{supertypes}.
We propose \emph{bottom-like} with \emph{subtypes}. This will be discussed
in detail in \Cref{sec:union}.

Adding intersection types in our calculus
together with union types poses non-trivial challenges on disjointness.
Specifically, it makes it impossible to define a complete disjointness
definition. Therefore, the simple disjointness definition which is dual
to $\lambda_{i}$ no longer works. We define a notion of ordinary types
and define disjointness based upon ordinary types to overcome the
challenge in completeness. Informally, updated disjointness definition states
that two types $[[A]]$ and $[[B]]$ are disjoint if they do not share any
common ordinary subtype. This will further be discussed in detail in
\Cref{sec:inter}.

We propose a sound and complete disjointness definition. Caclulus studied
in this paper is type-safe and deterministic.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% org-ref-default-bibliography: "../paper.bib"
%%% End: