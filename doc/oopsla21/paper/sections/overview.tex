\section{Overview}
\label{sec:overview}

This section provides some background on union types, and some common approaches
to eliminate union types. Then it describes the Ceylon approach to Union types.
Finally, it presents the key ideas and challenges in our work and \name.

\ningning{We may want to be consistent with the syntax used in examples. Now
  there are three things going on: examples before introducing Ceylon; examples
  in Ceylon; examples in our calculi. Will it look confusing as we use three
  different syntax rules?}
\bruno{Three different syntaxes is definitly too much. I think we may be able
  to get by with two syntaxes: our calculus and Ceylon. Alternatevely, we can
  use just the syntax in our calculus here, and later, perhaps in the discussion
  have examples in Ceylon, when comparing to Ceylon. }

\subsection{Tagged Union Types}

% Brief intro to union types and one or 2 simple examples that show that we
% can automatically lift values into union type without the need of some
% tag/constructor. Something like:

We start with a brief introduction to union types. An expression has a union
type $[[A\/B]]$, if it can be considered to have either type $[[A]]$ \textit{or}
type $[[B]]$. Many systems model \textit{tagged union types} (also called
\textit{sum types} or \textit{variants types}), where explicit \textit{tags}
are used to construct terms with union types. Languages with algebraic datatypes~\cite{hope}
or (polymorphic) variants~\cite{garrigue98} support tagged union types. 
In their basic form, there are two introduction forms:
$\mathsf{inj_1} :: [[A -> A \/ B]]$ turn the type of an expression of type
$[[A]]$ into type $[[A \/ B]]$; and $\mathsf{inj_2} :: [[B -> A \/ B]]$
turns the type of an expressions of type $[[B]]$ into type $[[A \/ B]]$.
For example, we can have:

\begin{lstlisting}
inj1 "foo": String | Int
inj2 1 : String | Int
\end{lstlisting}

\noindent Using tagged union types, we can implement a safe integer
division function, as:

\begin{lstlisting}
function safediv (x : Int) (y : Int) : String | Int =
  if (y == 0) then inj1 "Divided by zero"
  else inj2 (x / y)
\end{lstlisting}

\noindent Here the intention is to have a safe (integer) division operation that detects
division by zero errors, and requires clients of this function to handle
such errors. The return type \lstinline{String | Int} denotes that the function
can either return an error message (a string), or an integer, when division
is performed without errors.

\paragraph{Eliminating tagged union types.}
Tagged union types are eliminated by some form of case analysis.
For consistency with the rest of the paper, we use a syntactic form with
\lstinline{switch} expressions for such case analysis. For example,
the following program \lstinline{tostring} has different behaviors depending on the
tag of \lstinline{x}, where \lstinline{show} takes an \lstinline{Int} and
returns back its string representation.

\begin{lstlisting}
function tostring (x: String | Int) : String =
  switch x of
    inj1 str -> str
    inj2 num -> show num
\end{lstlisting}

Combining union type construction in \lstinline{safediv} and its elimination in
\lstinline{tostring}, we can easily implement an interface which returns the
result of safe division as one \lstinline{String}.

\begin{lstlisting}
> tostring (safediv 42 2)
"21"
> tostring (safe 42 0)
"Divided by zero"
\end{lstlisting}


\subsection{Type-directed Elimination of Union Types}\label{subsec:elimination}

% Motivate the need for having a construct that can eliminate union types,
% perhaps trying to use an example where the String above would be a kind
% of exception, and the Int would be regular computation. Alternatively
% find an existing example from the literature.

% Discussing existing approaches for eliminating union types;
% point out that elimination constructs based on types (our focus) vs
% elimination constructs based on tags (which are used in algebraic
% datatypes or polymorphic variants (like in OCaml)).
% The focus should be on type-based approaches.

% Try to identify some limitations/problems. For instance how to deal
% with ambiguity (just use order? restrict the construct somehow ...).


While tags are useful to make it explicit which type a value belongs to, they
also add clutter in the programs, and usually require extra space to store the
tags. On the other hand, in systems with subtyping for union types
\cite{dunfield2014elaborating,pierce1991programming,muehlboeck2018empowering},
explicit tags are replaced by implicit coercions represented by the two
subtyping rules $[[A <: A \/ B]]$ and $[[B <: A \/ B]]$. We call such types
\textit{untagged union types}, or simply \textit{union types}. In those systems,
a term of type $[[A]]$ or $[[B]]$ can be directly used as if it had type $[[A \/
B]]$, and thus we can model safe division as

\begin{lstlisting}
function safediv2 (x : Int) (y : Int) : String | Int =
  if (y == 0) then "Divided by zero"
  else (x / y)
\end{lstlisting}

\noindent However, now elimination of union types cannot rely on tags anymore, and
different systems implement elimination differently. We review some of the
existing approaches next.

\paragraph{Single branch elimination.}

A possible approach is to use an elimination of an
expression with a union type $[[A \/ B]]$ supports only one branch, and the
branch needs to have the same type when the expression has type $[[A]]$, or type
$[[B]]$. This approach is adopted, for example by \citet{pierce1991programming}
and \citet{dunfield2014elaborating}. For better illustration, we adapt their syntax
  using our switch notation in the examples, while preserving their semantics.
For example, in \lstinline{tostring2}, the expression \lstinline{show x} must return
\lstinline{String} when \lstinline{y : String}, and when \lstinline{y : Int},
which means that \lstinline{show} must be overloaded (in
\citet{pierce1991programming,dunfield2014elaborating}, this can be implemented
by requiring \lstinline{show} to have an \textit{intersection type}).

\begin{lstlisting}
function tostring2 (x: String | Int) : String =
  switch x of
    y -> show y
\end{lstlisting}

This implementation is concise, but it is also restrictive as it can no longer
support multiple branches according to the different representations of
\lstinline{x}. Furthermore it relies on the language also supporting overloaded
functions. Without overloaded functions the construct would not be very useful.
%\bruno{Perhaps, somewhere in this section we need to comment on the non-deterministic semantics.
%  Maybe we can do that here and point out, for instance, that Dunfield's approach has a
%  non-deterministic semantics (since it actually allows, for instance two overloaded
%  implementations of show with integer arguments)}

\paragraph{Type-directed elimination.}

On the other hand, some systems~\cite{} support \textit{type-directed} elimination
of union types. For instance, \lstinline{tostring3} has different behaviors
depending on the \textit{type} of \lstinline{x}.

\begin{lstlisting}
function tostring3 (x: String | Int) : String =
  switch x of
    String -> x
    Int -> show x
\end{lstlisting}

\noindent Note here \lstinline{show} is directly applied to \lstinline{x}, and
it does not need to be overloaded, as the type-directed elimination
\textit{refines} the type of \lstinline{x} from \lstinline{String | Int} to
\lstinline{Int} in the second branch (such type refinements are basically a form of
\textit{occurrence typing} \cite{Tobin:typedscheme}).

However, compared to tag-directed elimination, extra care must to taken with
type-directed elimination. In particular, while we can easily distinguish tags,
in type-directed elimination, ambiguity may arise when types in a union type
overlap. For example, consider the type \lstinline{Person | Student}, where we
assume \lstinline{Student} is a subtype of \lstinline{Person}. With tag-directed
elimination, we can write the following function:

\begin{lstlisting}
function isstudent (x: Person | Student) : Bool =
  switch x of
    inj1 person -> False
    inj2 student -> True
\end{lstlisting}

But if we transform this function straightforwardly to type-directed
elimination, we will get:

\begin{lstlisting}
function isstudent2 (x: Person | Student) : Bool =
  switch x of
    Person  -> False
    Student -> True
\end{lstlisting}

\noindent Now it is unclear what would happen if we apply \lstinline{isstudent2}
to a term of type \lstinline{Student}, as its type matches both branches. In some
calculi~\citep{dunfield2014elaborating},
the choice is not determined in the semantics, in the sense that either
branch can be chosen. This leads to a non-deterministic semantics. In some
other languages or calculi~\citep{}, branches are inspected from top to bottom, and the first one
that matches the type gets chosen. However, in those systems, as
\lstinline{Person} is a supertype of \lstinline{Student}, the first branch
subsumes the second one and will always get chosen, and so the second branch
will never get evaluated! This could be unintentional, and similar programs  
being accepted could lead to subtle bugs. Even if a warning could be given
to alert programmers that a case can never be executed, there could be
other situations where two cases overlap, but neither case subsumes the other.
For instance we could have \lstinline{Student} and \lstinline{Worker} as
subtypes of \lstinline{Person}. For a person that is both a student and a worker,
a switch statement that discriminates between workers and students could
potentially choose either branch. However for persons that are only students
or only workers, only one branch can be chosen.

\bruno{Ningning, as discussed earlier, I think in these 2 first sections we should also talk about
overloading and the best-match approach.}

\subsection{Eliminating Union Types in Ceylon}
Ceylon supports type-directed union elimination via a switch expression with
multiple branches. Each branch matches on a type.
At runtime, one branch is chosen according to the input's type.
A first example of a Ceylon program with union types and the elimination
construct is:

\begin{lstlisting}
	void print(String|Integer|Float x) {
		switch (x)
		case (is String) { print("String: ``x``"); }
		case (is Integer|Float) { print("Number: ``x``"); }
	}
\end{lstlisting}
%

Static type checking for the switch construct ensures two things: the
list of cases is \emph{exhaustive}, and all cases are
\emph{disjoint}. In the above example, \lstinline{x} can be either a
string, an integer or a floating point number. The types used in the
cases do not have to be exactly match with the types of
\lstinline{x}. Nevertheless, the combination of all cases must be
able to handle all possibilities. If the last case only dealt with
\lstinline{Integer} (instead of \lstinline{Integer|Float}), then
the program would be statically rejected, since no case would deal
with a floating point number. 
Moreover, unlike the other
approaches described in Section~\ref{subsec:elimination}, it is
impossible to have two branches that match with one input at the same
time, thanks to the disjointness restriction. For instance, if the
first case used the type \lstinline{String | Float} instead of
\lstinline{String}, the program would be rejected with a static type
error. Indeed, if the program were to be accepted, then the call
\lstinline{print(3.0)} would be ambigous, since the two branches could
deal with floating point numbers.
Note that, since the cases in a switch cannot overlap, their order is
irrelevant to the program's behavior and its evaluation result.

\subsubsection*{Union Types as an Alternative to Overloading}
A motivation of such type-directed union elimination in Ceylon is to
model a form of function overloading.
The following example, which is adapted from TypeScript's documentation\footnote{https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html},
demonstrates how to define an ``overloaded'' function \lstinline{padLeft},
which adds some padding to a string. The idea is that there can be two versions
of \lstinline{padLeft}: one where the second argument is a string; and
another where the second argument is an integer:

\begin{lstlisting}
String space(Integer n){
	if (n==0) {
		return "";
	} else {
		return " "+space(n-1);
	}
}

String padLeft(String v, String|Integer x){
	switch (x)
	case (is String) { return x+v; }
	case (is Integer) { return space(x)+v; }
}

print( padLeft("?", 5) ); // "     ?"
print( padLeft("World", "Hello ") ); // "Hello World"
\end{lstlisting}
%

In the two cases of the switch construct, there are two different implementations
for the \lstinline{padLeft} function: one appends a string to the left of \lstinline{v},
the other calls function \lstinline{space} to generate a string with \lstinline{x} spaces,
and then append that to \lstinline{v}.
Although statically \lstinline{x} has type \lstinline{String|Integer}, as a concrete value 
it can only be a string or an integer.
As such, when values with such types are passed to the function,
the corresponding branch is chosen and executed.

\subsubsection*{Other Applications of Union Types}
Besides being used for overloading, union types can be used for other purposes to.
For instance, we can easily encode the \lstinline{safediv} function in Section~\ref{subsec:elimination}
in Ceylon:
\bruno{Ceylon code for safediv and to string here, and some short piece of text about the
example}

Besides, such applications, one other interesting application
of union types in Ceylon is to encode nullable types (or optional types).
A similar approach to nullable types has also been recently proposed for Scala~\citep{nieto20nulls}.
The \lstinline{null} value is inhabited by the type \lstinline{A?},
which stands for \lstinline{A|Null}.
If we eliminate a value of type \lstinline{A|Null}, there has to be a branch to handle
the null value. \bruno{Say more about this, maybe show a (simplified)
  picture of the subtyping lattice?
The point is that Null is not a subtype of Object, right? so, by default object
types have no null value. }
%Similarly, one can use enumerated types to denote various special cases, or easily
%add another type to the argument type of an existing function when considering
%more possible inputs, to improve the program's robustness.
%Next, we will see how Ceylon's static type checking helps programmers.

\begin{comment}
\subsubsection*{Exhaustiveness}

Ceylon checks the exhaustiveness of a switch by comparing the union of all
cases and the switched term's type.
For the switch to be accepted, the former must be a supertype of the later.
%Recall that adding more components to a union type make it a supertype of the
%initial type, like \lstinline{Integer|Float} to \lstinline{Integer}.
That is to say a switch construct must have enough cases to handle all
possible runtime types of the term.
%
For example, here we define \lstinline{Node} by enumerating its subtypes.
It can be viewed as the union of \lstinline{Leaf} and \lstinline{Branch}.
Then in the function \lstinline{printTree} that takes a \lstinline{Node},
both cases are taken into consideration.
%
\begin{comment}
------------- THE OTHER EXAMPLE -----------------
Adding more subtype in it causes error in exhaustiveness checking in switch.
\begin{lstlisting}
interface Resource of File | Directory | Link { }
interface File satisfies Resource {}
interface Directory satisfies Resource {}
interface Link satisfies Resource {}

void printType(Resource resource){
	switch (resource) 
	case (is File) { print("File"); }
	case (is Directory) { print("Directory"); }
	case (is Link) { print("Link"); }
}
\end{lstlisting}

%
\begin{lstlisting}
abstract class Node() of Leaf | Branch {}

class Leaf(shared Object element) 
extends Node() {}

class Branch(shared Node left, shared Node right) 
extends Node() {}

void printTree(Node node) {
	switch (node)
	case (is Leaf) {
		print("Found a leaf: ``node.element``!");
	}
	case (is Branch) {
		printTree(node.left);
		printTree(node.right);
	}
}

printTree(Branch(Branch(Leaf("aap"), Leaf("noot")), Leaf("mies")));
\end{lstlisting}
% https://ceylon-lang.org/documentation/1.3/tour/types/
%
We can allow the input to be \lstinline{null} by replacing the argument type \lstinline{Node} by \lstinline{Node?}.
Ceylon uses union types to encode nullable types (or the optional types) in a 
type-safe way.
The null value is inhabited in \lstinline{Null}, and \lstinline{A?} stands for \lstinline{A|Null}.
If the switched term has a nullable type, the exhaustive checking makes sure there
is a branch to handle it.
%
Similarly, one can use enumerated types to denote various special cases, or easily
add another type to the argument type of an existing function when considering
more possible inputs, to improve the program's robustness.
%
If we can add more subtype in the declaration of \lstinline{Node} without
adapting the function definition, an compiling error will be raised:
case types must cover all cases of the switch type.
Such checking reminds programmers to keep consistent when changing the
related code and avoid potential runtime errors.

\bruno{The following example is better, and I guess useful to illustrate exhaustiveness.}
\begin{lstlisting}
	void printAfterPlusOne(Integer|String x) {
		switch (x)
		case (is Integer|Float) { print(x+1); }
		case (is String) { print("String:"+x); }
	}
\end{lstlisting}
%
Exhaustiveness checking does not prevent the cases in a switch to 
accept more than necessary.
For example, in the above function, even though \lstinline{x} cannot be
a \lstinline{Float}, it is not harmful for the first branch to expect
a term of \lstinline{Integer|Float}, since \lstinline{Integer|Float|String}
still covers \lstinline{Integer|String}.


\subsubsection*{Disjointness}
Ceylon prevents any pair of cases in a switch from overlapping.
And disjointness is introduced to describe such relation between two types.
Being disjoint means the non-existence of a value which can be assigned to
both types.
With the existence of subtyping, a branch in switch/case expression
can take a term of a subtype of its expected type.
Therefore disjointness roughly equals to no common subtype.
However, this does not directly lead to an algorithm. So Ceylon
provides a set of rules: 1) distinct cases in an enumerated type is thought to
be disjoint, and their subtypes are disjoint too; 2) two classes, if they are
not subclass of each other, are disjoint; and etc.
Especially, for a union type $[[A1\/A2]]$, being disjoint with another
type $B$ requires both $[[A1]]$ and $[[A2]]$ to be disjoint with $B$.
Eventually, after decomposing and examining subtyping relation, it is decidable
that two types are disjoint or not.

% https://github.com/ceylon/ceylon-spec/issues/50
% https://github.com/ceylon/ceylon-spec/issues/65

Disjointness is the foundation of
Ceylon's deterministic and order-irrelevant semantics of the switch construct.
Forcing all cases to be disjoint eliminates ambiguity, and avoid subtle bugs that may arize from overlapping cases.
%
People may argue that the programmer should be free to use overlapping cases
and arrange their order intentionally. The following example provides a scenario
where the programmer may not notice the dangerous overlapping.
%
\begin{lstlisting}
	alias Number => Integer | Null;
	String getNumber(Number n) {
		switch (n)
		case (is Integer) { return "``n``"; }
		case (is Null) { return "infinity"; }
		
	}
	void  printAge(Number|Null x) {
		switch (x)
		case (is Number) { print("Age is ``getNumber(x)``".); }
		case (is Null) { print("Age is not provided."); }
	}
\end{lstlisting}
%
Assume \lstinline{Number} is already defined where \lstinline{null} stands for
infinity. A client uses it to store age information. 
Meanwhile, the client use \lstinline{null} to denote missing data.
Without disjointness checking, the above code will be accepted.
But in \lstinline{printAge}, the second branch is always shadowed by the first one.
Any missing data will be interpreted as infinity.
%
Note that swapping the two cases cannot prevent all unexpected behaviors.
When the outside \lstinline{Null} has a different meaning other than infinity,
they are not distinguishable, and the branch designed for it will take them all.
% And instead of \lstinline{print}, one might call a function that takes care
% of \lstinline{Nothing} and the other component in \lstinline{A}.
This problem is even more serious when the language implements some syntax
sugar or encode other features via the switch/case construct.
It could be convenient to have a simple construct for unwrapping \lstinline{A|Null} without writing down the full switch/case expression.
But once the details are hidden, users may not be able to image that how does
the order affects the program, as we discussed above.  
On the other hand, with some requirements on the argument and return types, it is 
straightforward to support function overloading by combining them in a switch/case expression.
But it will be hard to find a fair criteria to decide which one
should be prioritized, if two functions can overlap.
% https://github.com/ceylon/ceylon-spec/issues/50
% https://github.com/ceylon/ceylon-spec/issues/65

In that case the meaning of infinity is hidden.
On contrary, disjoint cases are always distinguishable, and the user, when
using an existing definition, is guaranteed that there is no hidden conflicts.

\subsubsection*{The Bottom Type}
To dig deeper for disjointness, it often comes to the the concept
of \emph{bottom type}.
Bottom type is a subtype of all types, in contrast to the top type.
Certainly the bottom type has no value.
In Ceylon, it is called \lstinline{Nothing}, representing the empty set.
%
For two disjoint types $[[A]]$ and $[[B]]$, their intersection $[[A/\B]]$
is naturally a common subtype, and therefore must be equivalent to
the bottom type \lstinline{Nothing}.
\end{comment}

\subsubsection*{Existing Problems in Ceylon}
In general, a term of type $A$ is always assignable to any supertype of $A$.
But in Ceylon, the checking of assignability is not complete to
subtyping.
Although the subtyping relation holds between \lstinline{v}'s
(declarative) type and \lstinline{Integer}, \lstinline{v}
is not assignable to \lstinline{Integer}, and the following program
cannot be accepted by Ceylon's compiler.
% https://try.ceylon-lang.org/#

\begin{lstlisting}
	< Character | Integer > & < String | Integer > v = 100;
	switch (v)
	case (is Integer) { print("Integer: ``v``"); }
\end{lstlisting}

\begin{comment}
\bruno{Now you come back to disjointness having spoken about disjointness earlier
  in this section. Don't jump around topics like this. If you have a paragraph
  on disjointness, then talk about everything that relates to disjointness under that
  paragraph. Or maybe have another paragraph called ``Bottom-like Types just after
disjointness, since that's clearly related and should follow.}
To dig deeper for disjointness, it often comes to the the concept
of \emph{bottom type}.
Bottom type is a subtype of all types, in contrast to the top type.
Certainly the bottom type has no value.
In Ceylon, it is called \lstinline{Nothing}, representing the empty set.
%
With the existence of subtyping, a branch in switch/case expression
can take a term of a subtype of its expected type.
If the term's type is also a subtype of the other branch's expected
type, type information will be insufficient to disambiguate.
To prevent this, disjoint types cannot have any common subtype which has
inhabited values.
For two disjoint types $[[A]]$ and $[[B]]$, their intersection $[[A/\B]]$
is naturally a common subtype, and therefore must be equivalent to
the bottom type \lstinline{Nothing}.
\end{comment}

\begin{comment}
Let us call them \emph{bottom-like types}.
% Ceylon treat such types specially.
In a switch construct, every case has a type annotation.
In Ceylon, this type annotation is not allowed to be bottom-like.
The compiler uses this type to narrow the static type of the input term
in switch/case, and rejects the program if the resultant type is equivalent
to \lstinline{Nothing}.
\end{comment}
\subsection{Our Methodology}

The switch construct in our calculus \cal is similar to Ceylon's.
Its typing rule guarantees that cases are disjoint and exhaustive.
Reduction preserves types and produces deterministic result with
the help of annotated values.
Here we give an overview of our design and discuss some challenges
we met for the two calculi in the paper.

\subsubsection*{Disjointness, Interacted with Intersection Types}
After seeing the connection between bottom-like types and disjointness,
it is intuitive to formally define disjointness via bottom-like types.

\begin{definition}\label{def:disjointness}
	A $*_s$ B $\Coloneqq$ $\forall$ C, $[[C <: A]]$ $\wedge$ $[[C <: B]]$ $\rightarrow$ $[[botlike C]]$
	\label{def:union:disj}
\end{definition}

\snow{Here I copy the definition from union.tex. Maybe we can introduce it
earlier.}

Two types are disjoint if and only if all of their common subtypes are bottom-like.
That is to say, there does not exist any term that is assignable to both of
them.
For the detailed discussion and an algorithmic formalization of
disjointness, please refer to Section~\ref{sec:union:disj}.

In literature, there exist a very different definition of disjointness
in calculi with intersection types that also serves for disambiguity
purpose~\cite{oliveira2016disjoint}.
In contrary to subtypes, it restricts the common supertype, or the lowest
upper bound, of two disjoint types to be \emph{top-like}.
Similarly, a top-like type is equivalent to type top, which is the greatest
upper bound of all types.
The difference comes from the subtyping rules for intersections.
Any component of an intersection type is a supertype of it.
If two intersection types share a part, e.g. $[[Int/\Char]]$ and $[[String/\Int]]$
both contains $[[Int]]$, they cannot pass the disjointness checking.
Moreover, assuming $[[Odd]]$ and $[[Even]]$ denote odd numbers and even numbers,
they are both subtype of $[[Int]]$, and therefore are not disjoint.
The application of this definition is dual to our definition:
given a type that is not top-like, consider a scenario where we are looking for
a term that is assignable to the type. If all candidates' types are disjoint, 
at most one term can be chosen from them.
\begin{verbatim}
 (\x. x+1 : Int->Int) (1 ,, True) --> (1+1):Int
\end{verbatim}


In our second calculus , Definition~\ref{def:disjointness} is adapted
for intersection types.
We are forced to change it because with the existence of intersection types,
any two types $[[A]]$ $[[B]]$ have a trivial subtype $[[A/\B]]$. Generally such an intersection type is not bottom-like.
Our alternative definition of disjointness is presented in Section~\ref{sec:inter:disj}.
...


\snow{Next of the next: intersection types and distributivity}
\bruno{We don't need to say much about this, but maybe a few sentences are ok.}

\begin{verbatim}
LOS

LOS(top) = {Int, Bot -> Top}
LOS(Int -> Int) = â€¦.

\Cal differ with ceylon in subtyping
A disadvantage: We cannot reason that (String\/Null)/\Object <: String
\end{verbatim}

\subsubsection*{Typing and Exhaustiveness}

\snow{Next: How do we ensure exhaustive? Show the typing rule of switch/case.}
\bruno{Yes please: explain how exhaustiveness is ensured.}

\subsubsection*{Annotated Values}
\begin{verbatim}
	switch (1) {x:Int -> x+1, y:Bool -> not y} --> (1+1):Int
\end{verbatim}

in lambdai the return type must be different
\begin{verbatim}
	(\x. x+1 : Int->Int ,, \y. not y : Bool->Bool):Int->Int 1 --> (1+1):Int
\end{verbatim}

\bruno{
1) use of annotatted values for both reduction (the semantics must be type directed); and preservation;
2) Disjointness based on disjoint intersection, and later novel notion of disjointness in the presence of intersections;
3) LOS for algorithmic disjointness;
4) Dealing with exhaustiveness and reduction in the switch construct
}



\snow{Some concerns: does the addition of intersection types and distributivity
	really increase the expressiveness of the system?
	Currently the only interesting intersection type has the form of (A->B) \& (C->D),
	like (int->bool)\&(bool->int).
	But there is no way to construct a term of such type.
	The closest thing is $\lambda$ x.x, which has (int->int)\&(bool->bool).}
\bruno{Why don't you check examples from Ceylon? In any case, I don't think we need
to talk much about distributivity here: that is not our main focus.}

\bruno{For the following text, this is the level of detail that I expect
  for the introduction, but not for the overview! The overview should
  identify key ideas and challenges in more detail. So the following text
  is not what I'm hoping for here. For an example of what I'm hoping for here,
  see for instance Section 2.3 and 2.4 in ``Disjoint Intersection Types'' or
  Section 2.3, 2.4 and 2.5 in "A Type-Directed Operational Semantics for a
  Calculus with a Merge Operator''
}
In this paper, we follow type-based union elimination similar to Ceylon.
We enforce disjointness constraint on the types of branches of a switch
expression. On the contrary to Ceylon, we provide a formal definition
of disjointness. Our disjointness definition is inspired by $\lambda_{i}$ 
\cite{oliveira2016disjoint}. $\lambda_{i}$ formally defines disjointness
for intersection types and merge operator.
Intersection of two types $[[A]]$ and $[[B]]$ is dijoint in $\lambda_{i}$
if $[[A]]$ and $[[B]]$ do not share a common supertype which is not
\emph{top-like}. So-called \emph{top-like} types are defined in 
\cite{oliveira2016disjoint} and are such types which are \emph{supertypes}
of all other types.

Union types are usually considered to be dual of intersection types.
Therefore, we propose a dual definition of \emph{bottom-like} types.
In contrast to \emph{top-like} types, \emph{bottom-like} types are
subtypes of all other types. Further, in contrast to the disjointness
definition in $\lambda_{i}$, two types $[[A]]$ and $[[B]]$ in the simplest 
caluclus studied in this paper are disjoint if $[[A]]$ and $[[B]]$
do not share any common \emph{subtype} which is not \emph{bottom-like}.
Note that $\lambda_{i}$ proposed \emph{top-like} with \emph{supertypes}.
We propose \emph{bottom-like} with \emph{subtypes}. This will be discussed
in detail in \Cref{sec:union}.

Adding intersection types in our calculus
together with union types poses non-trivial challenges on disjointness.
Specifically, it makes it impossible to define a complete disjointness
definition. Therefore, the simple disjointness definition which is dual
to $\lambda_{i}$ no longer works. We define a notion of ordinary types
and define disjointness based upon ordinary types to overcome the
challenge in completeness. Informally, updated disjointness definition states
that two types $[[A]]$ and $[[B]]$ are disjoint if they do not share any
common ordinary subtype. This will further be discussed in detail in
\Cref{sec:inter}.

We propose a sound and complete disjointness definition. Caclulus studied
in this paper is type-safe and deterministic.

\bruno{
	Introduce our work, setting the goal to study the construct formally.
	Connect with the work on disjoint intersection types, which also
	employs a notion of disjointness, but for intersection. Explain that
	what is needed is a dual notion of disjointness.\\
	Introduce the first calculus, and explain that it is directly inspired
	by a dual notion of discjointness.\\
	Introduce the second calculus and identify a technical challenge with
	disjointness: the addition of intersection types breaks the previous
	notion of disjointness. Introduce the novel way to find disjoint types.\\
	Summarize/mention key results: type-safety; soundness/completeness of
	disjointness; determinism.\\
	Perhaps here it is also useful to identity, together with Baber, what
	were the most challenging aspects in the formalization, and maybe
	highlight these.
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% org-ref-default-bibliography: "../paper.bib"
%%% End:
