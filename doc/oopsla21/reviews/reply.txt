#Review A

- L 211: "Without overloaded functions the construct would not be very
useful."  The example would be better if it showed an overloading.

We do not show the definition of `show`, but the point is that show would be
on overloaded function with two implementations. For instance, we could have:

????

- L 429: Is there a difference between A \/ B and A|B ?

No (TODO: I think we have a sentence explaining this: look for it and
state it in the reply.)

- "There are two kinds of values: annotated values and
unannotated lambda expressions ($\lambda x. e$)."  This is not
consistent with Figure 1

We believe it is consistent. Values are defined in Fig 1 as:

Value     v ::= w | \x . e

w      --> annotated values (or AValue)
\x . e --> unannotated lambda expressions

- On the other hand, Figure 2 shows no rule for typing something of the
form $\lambda x.e : A \to B$

A value or expression of the form $\lambda x.e : A \to B$ is composed of two
different expressions:

1) an (unnanotted) lambda expression:  \lambda x.e;

2) and an annotated expression (e : A).

Encoding $\lambda x.e : A \to B$ in terms of those 2 expressions is a standard thing
todo in bidirectional type systems and it is basically found in most
papers that use bi-directional type-checking. For example, here is
a simple derivation tree that shows how to type-check `\x. x : Int -> Int`

- L 535: Now we have types in bold face, and yet more colons (again in
bold face).  Do these mean something different?

No, the bold face is just highlighting the examples, and the colon is a punctiation mark
in this case.

L 698: $e \Leftrightarrow A$ is not a judgement of Figure 2.

Yes, it is! It is the judgment Bi-directional Typing, whose form
shows up on line 600 inside a box. The notation for the judgement
form is exactly the same as the one used in the theorems that
the reviewer is complaining about:

T |- e <=> A

In this judgement the <=> is an argument of the relation (the mode), and
<=> is defined as:

<=>  ::=   => | <=

In Figure 1 (explained in lines 477-478 in the text).

1.  What is the problem the paper is trying to solve?
What properties should a solution to that problem have?

This paper is focused on the problem of elimination forms
for union types.

- Type-soundness
- determinism
- exclusivity of branches

2.  How are "dynamic types" different from the tags in tagged unions?

Two different aspects to understand union types:

1) Are tags needed to build expressions in the language with union types?

2) Is some extra information present at runtime (a tag or type) to help
indentifying the origin of the value?

We are talking about tagged vs untagged in the sense of 1). Our source
expressions do not need tags to build expressions that have union types.
We illustrate this with examples ...

Our semantics does indeed require types to be present at runtime, we will clarify this.

                                  |   C/C++ | Sum types   | Union Types in this paper (and much RW)
-------------------------------------------------------------------------------------------------
Tags for introduction of unions   |   No    | Yes         |     No
-------------------------------------------------------------------------------------------------
Tags or Types present at runtime  |   No    | Yes (Tags)  |     Yes (Type annotations)

3) What is the point of including Definition 2.1 and the material
that depends on it, rather than proceeding directly to Definition 2.2
and its consequences?
&
The paper presents two systems, one that supports intersection
types, and one that does not.  Why not just use the more powerful
one?

There are several reasons for this:

1) In PL Theory papers it is quite usual to identify minimal calculi with the
essence of the feature. Intersection types are an interesting feature that usually comes
paired up with union types, but they can be viewed as orthogonal/complementary.
Some languages, for example Julia, support union types
but not intersection types (at least as far as we know). Therefore, the designers
of such languages may be interested in calculi that have disjoint switches but not necessarely
intersections.

2) One important point of our work is to establish the relationship to the line
of work on disjoint intersection types. Again, in PL theory there are many papers
where the people explore the design of new features but in way that establish a
relationship (in this case via duality) to other more well-studied language features.

The formulation of disjointness in Section 3 is the direct dual of the notion
of disjointness for intersection types from past work, and the system with
union types, disjoint switches and the notion of disjointness can be viewed
as duals to notions that exist in calculi with dijoint intersection types.
If we discarded the calculus in Section 3 and the first notion of disjointness
this connection would not so direct or obvious.

#Review B

- I realize that “why” is not the focus of this paper. It is a “what and
how” paper. However, that makes it premature. Are you able to refer to
positive evidence (maybe in Ceylon) as to why it is vital to have
these constructs.

- I was confused by the claim in the abstract regarding empty
  types. The text of the paper refers only to the empty set. Where do
  the two converge?

By empty types we mean types that have no values inhabiting them.
For instance the Bottom type is uninhabited. Our LOS definition
in Fig 5, provides a way to find a class of empty types. In essence,
we have that:

if   |A| = {}   then A is an empty type.

So the relationship is the above: if the LOS of a type A is the
empty set, then A is an empty type. We exploit such observation in
Section 5.1.

Note that our notation |A| means the LOS of A.

#Review C

* Is there a closed expression of an intersection type?

Yes, there is. In the first calculus in Section 4, such expressions are
admitably trivial, but they do exist. For example:

```\x . x+1 : Int -> Int : (Int -> Int) /\ (Int -> Top)```

For the calculus with distributive subtyping in Section 5.2
we can build more interesting expressions with intersection types.
For example, we can write overloaded functions that have intersection types,
and where the match construct can serve the purpose of introducing intersections:

```
\x . switch x {
         (y : Int) => y+1
         (z : Bool) => if z then 1 else 0
     } : (Int \/ Bool) -> Int : (Int ->  Int) /\ (Bool -> Int) 
```

TODO: Study adding 

```
T |- e <= A     T |- e <= B
---------------------------
T |- e <= A & B
```

#Review D

- p.9 l.397
"Disjointness in the presence of intersection types"
The given reason is debatable: in many type systems all types which
are not inhabited are equivalent to the bottom type, therefore Int ∧
Bool should be equivalent to ⊥

We agree that this depends on what systems you are considering,
and we get back to this matter later on in the paper.
In particular, one of the extensions that we consider,
in Section 5.1, will indeed make `Int /\ Bool` equivalent to Bottom. 

- "(2) Additionally, the assumption ..."
This is a weak motivation; in the calculus of Oliveira et al. also Int and Bool are inhabited by
1,,True

Similarly to the previous answer, we want to emphasize that in the
paper we have also formalized a variant where Int /\ Bool are
equivalent to bottom. See Section 5.1. 

- p.19 sect.5.2 Subtyping Distributivity is a non-trivial extension
which would deserve more comments, examples and explanations.

For the final version we will dedicate more space to distributivity, with more
examples and a discussion about the algorithmic aspects.

- Sect.6 Related Work
I suggest to mention also the following papers which dea with union types for oo languages

Thank you for the suggestions. We will look into the papers. 


- Why does sect.5.2 present a declarative version for λu ?

The rules for the declarative version of subtyping are much simpler than
the algorithmic formulation. In subtyping relations with distributivity laws,
transitivity elimination is non-trivial (we cannot simply drop the transitivity rule).

Our Coq formalization comes with a formalization of a sound and complete algorithm
as well (which is not a contribution of our paper, but rather from a paper
that has just been conditionaly accepted at ICFP). But there are also a few
other algorithms in previous that could be employed.

In short, because the declarative rules are simpler, and the algorithmic formulation
that we use in Coq is not a contribution of this paper, we just present the declarative
formulation.

However, for the revision of the paper we will talk more about the algorithmic
formulation. 
