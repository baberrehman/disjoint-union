(* generated by Ott 0.28, locally-nameless from: ../spec/rules.ott *)
Require Import Metatheory.
(** syntax *)
Definition i := nat.

Inductive typ : Set :=  (*r type *)
 | t_int : typ
 | t_bot : typ
 | t_arrow (A:typ) (B:typ)
 | t_union (A:typ) (B:typ).

Inductive exp : Set :=  (*r expression *)
 | e_var_b (_:nat)
 | e_var_f (x:var)
 | e_lit (i5:i)
 | e_ann (e:exp) (A:typ)
 | e_abs (e:exp)
 | e_app (e1:exp) (e2:exp)
 | e_typeof (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp).

Inductive dirflag : Set :=  (*r typing direction *)
 | infer : dirflag
 | check : dirflag.

Definition ctx : Set := list ( atom * typ ).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | (e_var_b nat) => if (k === nat) then e_5 else (e_var_b nat)
  | (e_var_f x) => e_var_f x
  | (e_lit i5) => e_lit i5
  | (e_ann e A) => e_ann (open_exp_wrt_exp_rec k e_5 e) A
  | (e_abs e) => e_abs (open_exp_wrt_exp_rec (S k) e_5 e)
  | (e_app e1 e2) => e_app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (e_typeof e A e1 B e2) => e_typeof (open_exp_wrt_exp_rec k e_5 e) A (open_exp_wrt_exp_rec k e_5 e1) B (open_exp_wrt_exp_rec k e_5 e2)
end.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_e_var_f : forall (x:var),
     (lc_exp (e_var_f x))
 | lc_e_lit : forall (i5:i),
     (lc_exp (e_lit i5))
 | lc_e_ann : forall (e:exp) (A:typ),
     (lc_exp e) ->
     (lc_exp (e_ann e A))
 | lc_e_abs : forall (L:vars) (e:exp),
      ( forall x , x \notin  L  -> lc_exp  ( open_exp_wrt_exp e (e_var_f x) )  )  ->
     (lc_exp (e_abs e))
 | lc_e_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_app e1 e2))
 | lc_e_typeof : forall (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp),
     (lc_exp e) ->
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_typeof e A e1 B e2)).
(** free variables *)
Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | (e_var_b nat) => {}
  | (e_var_f x) => {{x}}
  | (e_lit i5) => {}
  | (e_ann e A) => (fv_exp e)
  | (e_abs e) => (fv_exp e)
  | (e_app e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (e_typeof e A e1 B e2) => (fv_exp e) \u (fv_exp e1) \u (fv_exp e2)
end.

(** substitutions *)
Fixpoint subst_exp (e_5:exp) (x5:var) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | (e_var_b nat) => e_var_b nat
  | (e_var_f x) => (if eq_var x x5 then e_5 else (e_var_f x))
  | (e_lit i5) => e_lit i5
  | (e_ann e A) => e_ann (subst_exp e_5 x5 e) A
  | (e_abs e) => e_abs (subst_exp e_5 x5 e)
  | (e_app e1 e2) => e_app (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
  | (e_typeof e A e1 B e2) => e_typeof (subst_exp e_5 x5 e) A (subst_exp e_5 x5 e1) B (subst_exp e_5 x5 e2)
end.


(** definitions *)

(* defns PreValue *)
Inductive pexpr : exp -> Prop :=    (* defn pexpr *)
 | pexpr_int : forall (i5:i),
     pexpr (e_lit i5)
 | pexpr_abs : forall (e:exp) (A B:typ),
     lc_exp (e_abs e) ->
     pexpr (e_ann  ( (e_abs e) )  (t_arrow A B)).

(* defns RExpr *)
Inductive rexpr : exp -> Prop :=    (* defn rexpr *)
 | rexpr_app : forall (e1 e2:exp),
     lc_exp e1 ->
     lc_exp e2 ->
     rexpr  ( (e_app e1 e2) ) 
 | rexpr_typeof : forall (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp),
     lc_exp e ->
     lc_exp e1 ->
     lc_exp e2 ->
     rexpr (e_typeof e A e1 B e2).

(* defns Value *)
Inductive value : exp -> Prop :=    (* defn value *)
 | value_val : forall (p:exp) (A:typ),
     pexpr p ->
     value (e_ann p A).

(* defns UExpr *)
Inductive uexpr : exp -> Prop :=    (* defn uexpr *)
 | uexpr_rexpr : forall (r:exp),
     rexpr r ->
     uexpr r
 | uexpr_pexpr : forall (p:exp),
     pexpr p ->
     uexpr p
 | uexpr_anno : forall (u:exp) (A:typ),
     uexpr u ->
     uexpr (e_ann u A).

(* defns FindType *)
Inductive findtype : exp -> typ -> Prop :=    (* defn findtype *)
 | findtype_int : forall (i5:i),
     findtype (e_lit i5) t_int
 | findtype_arrow : forall (e:exp) (A B:typ),
     lc_exp (e_abs e) ->
     findtype  ( (e_ann  ( (e_abs e) )  (t_arrow A B)) )   (t_arrow A B) ] .

(* defns BottomLike *)
Inductive bottomlike : typ -> Prop :=    (* defn bottomlike *)
 | bl_bot : 
     bottomlike t_bot
 | bl_or : forall (A B:typ),
     bottomlike A ->
     bottomlike B ->
     bottomlike (t_union A B).

(* defns Disjointness *)
Inductive disjointness : typ -> typ -> Prop :=    (* defn disjointness *)
 | ad_btmr : forall (A:typ),
     disjointness A t_bot
 | ad_btml : forall (A:typ),
     disjointness t_bot A
 | ad_intl : forall (A B:typ),
     disjointness t_int (t_arrow A B)
 | ad_intr : forall (A B:typ),
     disjointness (t_arrow A B) t_int
 | ad_orl : forall (A B C:typ),
     disjointness A C ->
     disjointness A C ->
     disjointness (t_union A B) C
 | ad_orr : forall (C A B:typ),
     disjointness A C ->
     disjointness A C ->
     disjointness C (t_union A B).

(* defns Subtyping *)
Inductive subtyping : typ -> typ -> Prop :=    (* defn subtyping *)
 | s_btm : forall (A:typ),
     subtyping t_bot A
 | s_int : 
     subtyping t_int t_int
 | s_arrow : forall (A1 A2 B1 B2:typ),
     subtyping B1 A1 ->
     subtyping A2 B2 ->
     subtyping (t_arrow A1 A2) (t_arrow B1 B2)
 | s_ora : forall (A1 A2 A:typ),
     subtyping A1 A ->
     subtyping A2 A ->
     subtyping (t_union A1 A2) A
 | s_orb : forall (A A1 A2:typ),
     subtyping A A1 ->
     subtyping A (t_union A1 A2)
 | s_orc : forall (A A1 A2:typ),
     subtyping A A2 ->
     subtyping A (t_union A1 A2).

(* defns Typing *)
Inductive typing : ctx -> exp -> dirflag -> typ -> Prop :=    (* defn typing *)
 | typ_lit : forall (G:ctx) (i5:i),
      uniq  G  ->
     typing G (e_lit i5) infer t_int
 | typ_var : forall (G:ctx) (x:var) (A:typ),
      uniq  G  ->
      binds  x A G  ->
     typing G (e_var_f x) infer A
 | typ_ann : forall (G:ctx) (e:exp) (A:typ),
     typing G e check A ->
     typing G (e_ann e A) infer A
 | typ_app : forall (G:ctx) (e1 e2:exp) (B A:typ),
     typing G e1 infer (t_arrow A B) ->
     typing G e2 check A ->
     typing G (e_app e1 e2) infer B
 | typ_sub : forall (G:ctx) (e:exp) (A B:typ),
     typing G e infer B ->
     subtyping B A ->
     typing G e check A
 | typ_abs : forall (L:vars) (G:ctx) (e:exp) (A B:typ),
      ( forall x , x \notin  L  -> typing  (( x ~ A )++ G )   ( open_exp_wrt_exp e (e_var_f x) )  check B )  ->
     typing G (e_abs e) check (t_arrow A B)
 | typ_typeof : forall (G:ctx) (e:exp) (A:typ) (e1:exp) (B:typ) (e2:exp) (C:typ) (x:var),
     typing G e check (t_union A B) ->
     typing  (( x ~ A )++ G )  e1 check C ->
     typing  (( x ~ B )++ G )  e2 check C ->
     disjointness A B ->
     typing G (e_typeof e A e1 B e2) check C.

(* defns Reduction *)
Inductive step : exp -> exp -> Prop :=    (* defn step *)
 | step_beta : forall (e:exp) (A1 B1 A2 B2:typ) (p:exp),
     lc_exp (e_abs e) ->
     pexpr p ->
     step (e_app  ( (e_ann (e_ann  ( (e_abs e) )  (t_arrow A1 B1)) (t_arrow A2 B2)) )  p) (e_ann  (  (open_exp_wrt_exp  e (e_ann p A1) )  )  B2)
 | step_vu : forall (v u:exp) (A:typ),
     lc_exp v ->
     lc_exp u ->
     step (e_app v  ( (e_ann u A) ) ) (e_app v u)
 | step_appl : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     step e1 e1' ->
     step (e_app e1 e2) (e_app e1' e2)
 | step_typeof : forall (e:exp) (A:typ) (e1:exp) (B:typ) (e2 e':exp),
     lc_exp e1 ->
     lc_exp e2 ->
     step e e' ->
     step (e_typeof e A e1 B e2) (e_typeof e' A e1 B e2)
 | step_appr : forall (v r e':exp),
     value v ->
     rexpr r ->
     step r e' ->
     step (e_app v r) (e_app v e')
 | step_ann_ann : forall (u:exp) (A B:typ),
     uexpr u ->
     step (e_ann (e_ann u A) B) (e_ann u B)
 | step_r_ann : forall (r:exp) (A:typ) (e':exp),
     rexpr r ->
     step r e' ->
     step (e_ann r A) (e_ann e' A)
 | step_int : forall (i5:i),
     step (e_lit i5) (e_ann (e_lit i5) t_int)
 | step_lam_ann : forall (e:exp) (A B:typ),
     lc_exp (e_abs e) ->
     step (e_ann  ( (e_abs e) )  (t_arrow A B)) (e_ann (e_ann  ( (e_abs e) )  (t_arrow A B)) (t_arrow A B))
 | step_typeofl : forall (p:exp) (A:typ) (e1:exp) (B:typ) (e2 e:exp) (x:var) (C:typ),
     lc_exp e1 ->
     lc_exp e2 ->
     lc_exp e ->
     pexpr p ->
     findtype p C ->
     subtyping C A ->
     step (e_typeof p A e1 B e2)  (open_exp_wrt_exp  e (e_ann p A) ) 
 | step_typeofr : forall (p:exp) (A:typ) (e1:exp) (B:typ) (e2 e:exp) (x:var) (C:typ),
     lc_exp e1 ->
     lc_exp e2 ->
     lc_exp e ->
     pexpr p ->
     findtype p C ->
     subtyping C B ->
     step (e_typeof p A e1 B e2)  (open_exp_wrt_exp  e (e_ann p B) ) .


(** infrastructure *)
Hint Constructors pexpr rexpr value uexpr findtype bottomlike disjointness subtyping typing step lc_exp.


