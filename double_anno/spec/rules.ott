% key idea: keep the original annotation and the outermost one for lambdas

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar var, x ::= {{ repr-locally-nameless }}

metavar i ::= {{ coq nat }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

  typ, A, B, C             :: 't_' ::=     {{ com type }}
    | Int                  ::   :: int     {{ tex \mathsf{Int}  }}
    | Bot                  ::   :: bot     {{ tex \bot }}
    | A -> B               ::   :: arrow
    | A \/ B 	             ::   :: union
    | ( A )                :: S :: paren   {{ coq [[A]]] }}

  exp, e, v, p, u, r       :: 'e_' ::=     {{ com expression }}
    | x                    ::   :: var
    | i                    ::   :: lit
    | e : A                ::   :: ann
    | \ x . e              ::   :: abs     (+ bind x in e +)
    | e1 e2                ::   :: app
    | typeof e as A e1 B e2 ::  :: typeof {{ tex typeof \ [[e]] \ as \ [[A]] \ [[e1]] \ [[B]] \ [[e2]] }}
    {{ tex typeof \ [[e]] \ as \ \{x:[[A]][[->]][[e1]], x:[[B]][[->]][[e2]]\}  }}
    | ( e )                :: S :: paren   {{ coq ([[e]]]) }}
    | e1 [ x ~> e2 ]       :: M :: subst   {{ coq (open_exp_wrt_exp [[x e1]][[e2]]) }}

substitutions
  single exp x   :: subst

freevars
  exp x      :: fv

parsing
  t_arrow right t_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar

  ctx, G {{ tex \Gamma }} :: 'ctx_' ::=    {{ com typing context }}
                                           {{ coq list ( atom * typ ) }}
    | []                   ::  :: empty    {{ coq nil }}
                                           {{ tex \cdot }}
    | G , x : A            ::  :: cons     {{ coq (([[x]]~[[T]])++[[G]]) }}

  dirflag :: '' ::=                        {{ com typing direction }}
    | =>                   ::  :: infer    {{ tex \Rightarrow }}
    | <=                   ::  :: check    {{ tex \Leftarrow }}

terminals :: 'terminals_' ::=
  | \                    ::  :: lambda     {{ tex \lambda }}
  | -->                  ::  :: red        {{ tex \longrightarrow }}
  | ~>                   ::  :: leadsto    {{ tex \leadsto }}
  | ->                   ::  :: arrow      {{ tex \rightarrow }}
  | \/                   ::  :: or         {{ tex \vee }}
  | |-                   ::  :: turnstile  {{ tex \vdash }}
  | <:                   ::  :: sub        {{ tex \textless: }}
  | in                   ::  :: in         {{ tex \in }}
  | ;                    ::  :: ctxAnd     {{ tex ; }}
  | fv                   ::  :: fv         {{ tex \mathsf{fv}\! }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | not formula              :: M :: not
    {{ tex \neg [[formula]] }}
    {{ coq not ([[formula]]) }}
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
    {{ tex  }}
  | x : A in G               ::   :: inG
    {{ coq binds [[x]][[A]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
    {{ tex [[x]] \notin [[G]] }}


defns
PreValue :: '' ::=
  
  defn
  prevalue e ::   :: pexpr :: 'pexpr_'
  {{ com PreValues }}
  by

    ------------ :: app
    prevalue i

    --------------------------- :: abs
    prevalue (\x.e) : A -> B


defns
RExpr :: '' ::=
  
  defn
  rexpr e ::   :: rexpr :: 'rexpr_'
  {{ com RExpr }}
  by

    ------------ :: app
    rexpr (e1 e2)

    --------------------------- :: typeof
    rexpr typeof e as A e1 B e2


defns
Value :: '' ::=
  
  defn
  value e ::   :: value :: 'value_'
  {{ com Values }}
  by

    prevalue p
    ------------ :: val
    value p : A


defns
UExpr :: '' ::=
  
  defn
  uexpr e ::   :: uexpr :: 'uexpr_'
  {{ com UEpxr }}
  by

    rexpr r
    ------------ :: rexpr
    uexpr r


    prevalue p
    ------------ :: pexpr
    uexpr p


    uexpr u
    ------------ :: anno
    uexpr u : A


defns
BottomLike :: '' ::=

  defn
  botLike A ::  :: bottomlike :: 'bl_'
  {{ tex \rfloor [[A]] \lfloor}}
  {{ com Bottom-Like Types }}
  by

    -------------------- :: bot
    botLike Bot

    botLike A
    botLike B
    -------------------------     :: or
    botLike A \/ B


defns
Disjointness :: '' ::=

  defn
  A * B ::  :: disjointness :: ad_
  {{ tex [[A]] *_a [[B]] }}
  {{ com Disjointness }}

  by

  -------------------- :: btmr
  A * Bot

  -------------------- :: btml
  Bot * A

  
  -------------------- :: intl
  Int * A -> B
  
  
  -------------------- :: intr
  A -> B * Int
  

  A * C
  A * C
  -------------------------     :: orl
  A \/ B * C
  
  
  A * C
  A * C
  -------------------------     :: orr
  C * A \/ B
  

defns
Subtyping :: '' ::=

defn

A <: B ::  :: subtyping :: s_
  {{ com Subtyping }}
by

  -------------------- :: btm
  Bot <: A
  
  
  -------------------- :: int
  Int <: Int
  
  
  B1 <: A1 
  A2 <: B2
  -------------------------     :: arrow
  A1 -> A2 <: B1 -> B2
  
  
  A1 <: A
  A2 <: A
  -------------------------     :: ora
  A1 \/ A2 <: A
  
  
  A <: A1
  -------------------------     :: orb
  A <: A1 \/ A2 
  
  
  A <: A2
  -------------------------     :: orc
  A <: A1 \/ A2


defns
Typing :: '' ::=

  defn
  G |- e dirflag A ::   :: typing :: 'typ_'
  {{ com Typing Rules }}
  by

    % inference mode

    uniq G
    ----------------- :: lit
    G |- i => Int

    uniq G
    x : A in G
    -------------- :: var
    G |- x => A

    G |- e <= A
    ------------------ :: ann
    G |- e : A => A

    G |- e1 => A -> B
    G |- e2 <= A
    -------------------- :: app
    G |- e1 e2 => B

    % checking mode

    G |- e => B
    B <: A
    -------------- :: sub
    G |- e <= A

    G, x:A |- e <= B
    -------------------------- :: abs
    G |- \x. e <= A -> B

    G |- e <= A \/ B
    G, x : A |- e1 <= C
    G, x : B |- e2 <= C
    A * B
    --------------------------------- :: typeof
    G |- typeof e as A e1 B e2 <= C


defns
Reduction :: '' ::=

  defn
  e --> e' ::   :: step :: 'step_'
  {{ com Small-step operational semantics }}
  by

    value v
    ---------------------------------------------- :: beta
    (((\x.e): A -> B)) p --> (e [x ~> p:A]):B

%    ??? C
%    ---------------------------------------------- :: beta
%    (\x.e):A->B:C v --> (e [x ~> v:A]):B

   
   ----------------------- :: vu
   v (u : A) --> v u


   e --> e'
   ------------------------------------------------- :: typeof
   typeof e as A e1 B e2 --> typeof e' as A e1 B e2

    e1 --> e1'
    ---------------- :: appl
    e1 e2 --> e1' e2

    value v
    r --> e'
    ---------------- :: appr
    v r --> v e'

    not value e:A
    e --> e'
    ---------------- :: anno
    e:A --> e':A

    --------------------- :: ann_ann
    e : A : B --> e : B


    r --> e'
    ----------------------- :: r_ann
    r : A --> e' : A


    ------------------------ :: int
    i --> i : Int
  
    
    --------------------------------- :: lam_ann
    (\x.e):A->B --> (\x.e):A->B:A->B
